# Quansheng UV-K5 driver (c) 2023 Jacek Lipkowski <sq5bpf@lipkowski.org>
# Modified for Full Chinese Firmware by hank9999
#
# based on template.py Copyright 2012 Dan Smith <dsmith@danplanet.com>
#
#
# This is a preliminary version of a driver for the UV-K5
# It is based on my reverse engineering effort described here:
# https://github.com/sq5bpf/uvk5-reverse-engineering
#
# Warning: this driver is experimental, it may brick your radio,
# eat your lunch and mess up your configuration.
#
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


import struct
import logging

from chirp import chirp_common, directory, bitwise, memmap, errors, util
from chirp.errors import InvalidValueError
from chirp.settings import RadioSetting, RadioSettingGroup, \
      RadioSettingValueBoolean, RadioSettingValueList, \
      RadioSettingValueInteger, RadioSettingValueString, \
      RadioSettings, RadioSettingValue

LOG = logging.getLogger(__name__)

# Show the obfuscated version of commands. Not needed normally, but
# might be useful for someone who is debugging a similar radio
DEBUG_SHOW_OBFUSCATED_COMMANDS = False

# Show the memory being written/received. Not needed normally, because
# this is the same information as in the packet hexdumps, but
# might be useful for someone debugging some obscure memory issue
DEBUG_SHOW_MEMORY_ACTIONS = False

MEM_FORMAT = """
#seekto 0x0000;
struct {
  ul32 freq;
  ul32 offset;
  u8 rxcode;
  u8 txcode;

  u8 unknown1:2,
  txcodeflag:2,
  unknown2:2,
  rxcodeflag:2;

  //u8 flags1;
  u8 flags1_unknown7:1,
  flags1_unknown6:1,
  flags1_unknown5:1,
  enable_am:1,
  flags1_unknown3:1,
  is_in_scanlist:1,
  shift:2;

  //u8 flags2;
  u8 flags2_unknown7:1,
  flags2_unknown6:1,
  flags2_unknown5:1,
  bclo:1,
  txpower:2,
  bandwidth:1,
  freq_reverse:1;

  //u8 dtmf_flags;
  u8 dtmf_flags_unknown7:1,
  dtmf_flags_unknown6:1,
  dtmf_flags_unknown5:1,
  dtmf_flags_unknown4:1,
  dtmf_flags_unknown3:1,
  dtmf_pttid:2,
  dtmf_decode:1;


  u8 step;
  u8 scrambler;
} channel[214];

#seekto 0xd60;
struct {
u8 is_scanlist1:1,
is_scanlist2:1,
unknown1:1,
unknown2:1,
is_free:1,
band:3;
} channel_attributes[200];

#seekto 0xe40;
ul16 fmfreq[20];

#seekto 0xe70;
u8 call_channel;
u8 squelch;
u8 max_talk_time;
u8 noaa_autoscan;
u8 key_lock;
u8 vox_switch;
u8 vox_level;
u8 mic_gain;
u8 unknown3;
u8 channel_display_mode;
u8 crossband;
u8 battery_save;
u8 dual_watch;
u8 backlight_auto_mode;
u8 tail_note_elimination;
u8 vfo_open;

#seekto 0xe90;
u8 beep_control;

#seekto 0xe95;
u8 scan_resume_mode;
u8 auto_keypad_lock;
u8 power_on_dispmode;
u8 password[4];

#seekto 0xea0;
u8 keypad_tone;
u8 language;

#seekto 0xea8;
u8 alarm_mode;
u8 reminding_of_end_talk;
u8 repeater_tail_elimination;

#seekto 0xeb0;
char logo_line1[16];
char logo_line2[16];

#seekto 0xed0;
struct {
u8 side_tone;
char separate_code;
char group_call_code;
u8 decode_response;
u8 auto_reset_time;
u8 preload_time;
u8 first_code_persist_time;
u8 hash_persist_time;
u8 code_persist_time;
u8 code_interval_time;
u8 permit_remote_kill;
} dtmf_settings;

#seekto 0xee0;
struct {
char dtmf_local_code[3];
char unused1[5];
char kill_code[5];
char unused2[3];
char revive_code[5];
char unused3[3];
char dtmf_up_code[16];
char dtmf_down_code[16];
} dtmf_settings_numbers;

#seekto 0xf18;
u8 scanlist_default;
u8 scanlist1_priority_scan;
u8 scanlist1_priority_ch1;
u8 scanlist1_priority_ch2;
u8 scanlist2_priority_scan;
u8 scanlist2_priority_ch1;
u8 scanlist2_priority_ch2;
u8 scanlist_unknown_0xff;


#seekto 0xf40;
u8 lock_flock;

#seekto 0xf42;
u8 lock_killed;

#seekto 0xf46;
u8 lock_enscramble;

#seekto 0xf50;
struct {
char name[16];
} channelname[200];

#seekto 0x1c00;
struct {
char name[8];
char number[3];
char unused_00[5];
} dtmfcontact[16];

#seekto 0x1d00;
struct {
    u8 id[2];
    char name[14];
} mdccontact1[16];

#seekto 0x1ed0;
struct {
struct {
    u8 start;
    u8 mid;
    u8 end;
} low;
struct {
    u8 start;
    u8 mid;
    u8 end;
} medium;
struct {
    u8 start;
    u8 mid;
    u8 end;
} high;
u8 unused_00[7];
} perbandpowersettings[7];

#seekto 0x1f40;
ul16 battery_level[6];

#seekto 0x1f90;
struct {
    u8 id[2];
    char name[14];
} mdccontact2[6];

#seekto 0x1ff8;
u8 mkey_longpress_action;
u8 key1_shortpress_action;
u8 key1_longpress_action;
u8 key2_shortpress_action;
u8 key2_longpress_action;

#seekto 0x1fff;
u8 mdc_num;
"""
# bits that we will save from the channel structure (mostly unknown)
SAVE_MASK_0A = 0b11001100
SAVE_MASK_0B = 0b11101100
SAVE_MASK_0C = 0b11100000
SAVE_MASK_0D = 0b11111000
SAVE_MASK_0E = 0b11110001
SAVE_MASK_0F = 0b11110000

# flags1
FLAGS1_OFFSET_NONE = 0b00
FLAGS1_OFFSET_MINUS = 0b10
FLAGS1_OFFSET_PLUS = 0b01

POWER_HIGH = 0b10
POWER_MEDIUM = 0b01
POWER_LOW = 0b00

# dtmf_flags
PTTID_LIST = ["不发送", "开始上线码", "结束下线码", "开始+结束"]

# power
UVK5_POWER_LEVELS = [chirp_common.PowerLevel("低",  watts=1.50),
                     chirp_common.PowerLevel("中",  watts=3.00),
                     chirp_common.PowerLevel("高", watts=5.00),
                     ]

# scrambler
SCRAMBLER_LIST = ["关闭", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10"]

# channel display mode
CHANNELDISP_LIST = ["频率", "信道号", "名称", "名称+频率"]
# battery save
BATSAVE_LIST = ["关闭", "1:1", "1:2", "1:3", "1:4"]

# Backlight auto mode
BACKLIGHT_LIST = ["关闭", "5秒", "10秒", "20秒", "1分钟", "2分钟", "4分钟", "开启"]

# Crossband receiving/transmitting
CROSSBAND_LIST = ["关闭", "A段", "B段"]
DUALWATCH_LIST = CROSSBAND_LIST

# steps
STEPS = [2.5, 5.0, 6.25, 10.0, 12.5, 25.0, 8.33]

# ctcss/dcs codes
TMODES = ["", "Tone", "DTCS", "DTCS"]
TONE_NONE = 0
TONE_CTCSS = 1
TONE_DCS = 2
TONE_RDCS = 3


CTCSS_TONES = [
    67.0, 69.3, 71.9, 74.4, 77.0, 79.7, 82.5, 85.4,
    88.5, 91.5, 94.8, 97.4, 100.0, 103.5, 107.2, 110.9,
    114.8, 118.8, 123.0, 127.3, 131.8, 136.5, 141.3, 146.2,
    151.4, 156.7, 159.8, 162.2, 165.5, 167.9, 171.3, 173.8,
    177.3, 179.9, 183.5, 186.2, 189.9, 192.8, 196.6, 199.5,
    203.5, 206.5, 210.7, 218.1, 225.7, 229.1, 233.6, 241.8,
    250.3, 254.1
]

# lifted from ft4.py
DTCS_CODES = [
    23,  25,  26,  31,  32,  36,  43,  47,  51,  53,  54,
    65,  71,  72,  73,  74,  114, 115, 116, 122, 125, 131,
    132, 134, 143, 145, 152, 155, 156, 162, 165, 172, 174,
    205, 212, 223, 225, 226, 243, 244, 245, 246, 251, 252,
    255, 261, 263, 265, 266, 271, 274, 306, 311, 315, 325,
    331, 332, 343, 346, 351, 356, 364, 365, 371, 411, 412,
    413, 423, 431, 432, 445, 446, 452, 454, 455, 462, 464,
    465, 466, 503, 506, 516, 523, 526, 532, 546, 565, 606,
    612, 624, 627, 631, 632, 654, 662, 664, 703, 712, 723,
    731, 732, 734, 743, 754
]

FLOCK_LIST = ["默认+137-174 400-430", "FCC", "CE", "GB", "137-174 400-430", "137-174 400-438", "禁用全部", "解锁全部"]

SCANRESUME_LIST = ["TO: 收到信号5秒后恢复",
                   "CO: 信号消失后恢复",
                   "SE: 收到信号后停止扫描"]

WELCOME_LIST = ["关闭", "图片", "信息"]
KEYPADTONE_LIST = ["关闭", "中文", "English"]
LANGUAGE_LIST = ["中文", "English"]
ALARMMODE_LIST = ["本地", "本地+远端"]
REMENDOFTALK_LIST = ["关闭", "ROGER尾音", "MDC尾音", "MDC首音", "MDC首尾音", "MDC首音+ROGER"]
RTE_LIST = ["关闭", "100ms", "200ms", "300ms", "400ms",
            "500ms", "600ms", "700ms", "800ms", "900ms"]

MEM_SIZE = 0x2000  # size of all memory
PROG_SIZE = 0x1e00  # size of the memory that we will write
MEM_BLOCK = 0x80  # largest block of memory that we can reliably write

# fm radio supported frequencies
FMMIN = 64.0
FMMAX = 108.0

# bands supported by the UV-K5
BANDS = {
        0: [50.0, 76.0],
        1: [108.0, 135.9999],
        2: [136.0, 199.9990],
        3: [200.0, 299.9999],
        4: [350.0, 399.9999],
        5: [400.0, 469.9999],
        6: [470.0, 600.0]
        }

# for radios with modified firmware:
BANDS_NOLIMITS = {
        0: [18.0, 76.0],
        1: [108.0, 135.9999],
        2: [136.0, 199.9990],
        3: [200.0, 299.9999],
        4: [350.0, 399.9999],
        5: [400.0, 469.9999],
        6: [470.0, 1300.0]
        }

SPECIALS = {
        "F1(50M-76M)A": 200,
        "F1(50M-76M)B": 201,
        "F2(108M-136M)A": 202,
        "F2(108M-136M)B": 203,
        "F3(136M-174M)A": 204,
        "F3(136M-174M)B": 205,
        "F4(174M-350M)A": 206,
        "F4(174M-350M)B": 207,
        "F5(350M-400M)A": 208,
        "F5(350M-400M)B": 209,
        "F6(400M-470M)A": 210,
        "F6(400M-470M)B": 211,
        "F7(470M-600M)A": 212,
        "F7(470M-600M)B": 213
        }

VFO_CHANNEL_NAMES = ["F1(50M-76M)A", "F1(50M-76M)B",
                     "F2(108M-136M)A", "F2(108M-136M)B",
                     "F3(136M-174M)A", "F3(136M-174M)B",
                     "F4(174M-350M)A", "F4(174M-350M)B",
                     "F5(350M-400M)A", "F5(350M-400M)B",
                     "F6(400M-470M)A", "F6(400M-470M)B",
                     "F7(470M-600M)A", "F7(470M-600M)B"]

SCANLIST_LIST = ["无", "1", "2", "1+2"]

DTMF_CHARS = "0123456789ABCD*# "
DTMF_CHARS_ID = "0123456789ABCDabcd"
DTMF_CHARS_KILL = "0123456789ABCDabcd"
DTMF_CHARS_UPDOWN = "0123456789ABCDabcd#* "
DTMF_CODE_CHARS = "ABCD*# "
DTMF_DECODE_RESPONSE_LIST = ["关闭", "本地响铃", "回复响应", "响铃+回复"]

KEYACTIONS_LONG_LIST = ["无", "手电筒", "切换发射功率", "监听", "扫描", "声控发射", "FM收音机", "锁定按键", "切换AB信道",
                        "切换信道模式", "切换调制模式", "DTMF解码", "切换宽窄带", "A信道发射", "B信道发射"]

KEYACTIONS_SHORT_LIST = ["无", "手电筒", "切换发射功率", "监听", "扫描", "声控发射", "FM收音机", "锁定按键", "切换AB信道",
                         "切换信道模式", "切换调制模式", "DTMF解码", "切换宽窄带"]

MIC_GAIN_LIST = ["+1.1dB", "+4.0dB", "+8.0dB", "+12.0dB", "+15.1dB"]

FONT_MAPPING = ['啊', '阿', '埃', '挨', '哎', '唉', '哀', '皑', '癌', '蔼', '矮', '艾', '碍', '爱', '隘', '鞍', '氨', '安', '俺', '按', '暗', '岸', '胺', '案', '肮', '昂', '盎', '凹', '敖', '熬', '翱', '袄', '傲', '奥', '懊', '澳', '芭', '捌', '扒', '叭', '吧', '笆', '八', '疤', '巴', '拔', '跋', '靶', '把', '耙', '坝', '霸', '罢', '爸', '白', '柏', '百', '摆', '佰', '败', '拜', '稗', '斑', '班', '搬', '扳', '般', '颁', '板', '版', '扮', '拌', '伴', '瓣', '半', '办', '绊', '邦', '帮', '梆', '榜', '膀', '绑', '棒', '磅', '蚌', '镑', '傍', '谤', '苞', '胞', '包', '褒', '剥', '薄', '雹', '保', '堡', '饱', '宝', '抱', '报', '暴', '豹', '鲍', '爆', '杯', '碑', '悲', '卑', '北', '辈', '背', '贝', '钡', '倍', '狈', '备', '惫', '焙', '被', '奔', '苯', '本', '笨', '崩', '绷', '甭', '泵', '蹦', '迸', '逼', '鼻', '比', '鄙', '笔', '彼', '碧', '蓖', '蔽', '毕', '毙', '毖', '币', '庇', '痹', '闭', '敝', '弊', '必', '辟', '壁', '臂', '避', '陛', '鞭', '边', '编', '贬', '扁', '便', '变', '卞', '辨', '辩', '辫', '遍', '标', '彪', '膘', '表', '鳖', '憋', '别', '瘪', '彬', '斌', '濒', '滨', '宾', '摈', '兵', '冰', '柄', '丙', '秉', '饼', '炳', '病', '并', '玻', '菠', '播', '拨', '钵', '波', '博', '勃', '搏', '铂', '箔', '伯', '帛', '舶', '脖', '膊', '渤', '泊', '驳', '捕', '卜', '哺', '补', '埠', '不', '布', '步', '簿', '部', '怖', '擦', '猜', '裁', '材', '才', '财', '睬', '踩', '采', '彩', '菜', '蔡', '餐', '参', '蚕', '残', '惭', '惨', '灿', '苍', '舱', '仓', '沧', '藏', '操', '糙', '槽', '曹', '草', '厕', '策', '侧', '册', '测', '层', '蹭', '插', '叉', '茬', '茶', '查', '碴', '搽', '察', '岔', '差', '诧', '拆', '柴', '豺', '搀', '掺', '蝉', '馋', '谗', '缠', '铲', '产', '阐', '颤', '昌', '猖', '场', '尝', '常', '长', '偿', '肠', '厂', '敞', '畅', '唱', '倡', '超', '抄', '钞', '朝', '嘲', '潮', '巢', '吵', '炒', '车', '扯', '撤', '掣', '彻', '澈', '郴', '臣', '辰', '尘', '晨', '忱', '沉', '陈', '趁', '衬', '撑', '称', '城', '橙', '成', '呈', '乘', '程', '惩', '澄', '诚', '承', '逞', '骋', '秤', '吃', '痴', '持', '匙', '池', '迟', '弛', '驰', '耻', '齿', '侈', '尺', '赤', '翅', '斥', '炽', '充', '冲', '虫', '崇', '宠', '抽', '酬', '畴', '踌', '稠', '愁', '筹', '仇', '绸', '瞅', '丑', '臭', '初', '出', '橱', '厨', '躇', '锄', '雏', '滁', '除', '楚', '础', '储', '矗', '搐', '触', '处', '揣', '川', '穿', '椽', '传', '船', '喘', '串', '疮', '窗', '幢', '床', '闯', '创', '吹', '炊', '捶', '锤', '垂', '春', '椿', '醇', '唇', '淳', '纯', '蠢', '戳', '绰', '疵', '茨', '磁', '雌', '辞', '慈', '瓷', '词', '此', '刺', '赐', '次', '聪', '葱', '囱', '匆', '从', '丛', '凑', '粗', '醋', '簇', '促', '蹿', '篡', '窜', '摧', '崔', '催', '脆', '瘁', '粹', '淬', '翠', '村', '存', '寸', '磋', '撮', '搓', '措', '挫', '错', '搭', '达', '答', '瘩', '打', '大', '呆', '歹', '傣', '戴', '带', '殆', '代', '贷', '袋', '待', '逮', '怠', '耽', '担', '丹', '单', '郸', '掸', '胆', '旦', '氮', '但', '惮', '淡', '诞', '弹', '蛋', '当', '挡', '党', '荡', '档', '刀', '捣', '蹈', '倒', '岛', '祷', '导', '到', '稻', '悼', '道', '盗', '德', '得', '的', '蹬', '灯', '登', '等', '瞪', '凳', '邓', '堤', '低', '滴', '迪', '敌', '笛', '狄', '涤', '翟', '嫡', '抵', '底', '地', '蒂', '第', '帝', '弟', '递', '缔', '颠', '掂', '滇', '碘', '点', '典', '靛', '垫', '电', '佃', '甸', '店', '惦', '奠', '淀', '殿', '碉', '叼', '雕', '凋', '刁', '掉', '吊', '钓', '调', '跌', '爹', '碟', '蝶', '迭', '谍', '叠', '丁', '盯', '叮', '钉', '顶', '鼎', '锭', '定', '订', '丢', '东', '冬', '董', '懂', '动', '栋', '侗', '恫', '冻', '洞', '兜', '抖', '斗', '陡', '豆', '逗', '痘', '都', '督', '毒', '犊', '独', '读', '堵', '睹', '赌', '杜', '镀', '肚', '度', '渡', '妒', '端', '短', '锻', '段', '断', '缎', '堆', '兑', '队', '对', '墩', '吨', '蹲', '敦', '顿', '囤', '钝', '盾', '遁', '掇', '哆', '多', '夺', '垛', '躲', '朵', '跺', '舵', '剁', '惰', '堕', '蛾', '峨', '鹅', '俄', '额', '讹', '娥', '恶', '厄', '扼', '遏', '鄂', '饿', '恩', '而', '儿', '耳', '尔', '饵', '洱', '二', '贰', '发', '罚', '筏', '伐', '乏', '阀', '法', '珐', '藩', '帆', '番', '翻', '樊', '矾', '钒', '繁', '凡', '烦', '反', '返', '范', '贩', '犯', '饭', '泛', '坊', '芳', '方', '肪', '房', '防', '妨', '仿', '访', '纺', '放', '菲', '非', '啡', '飞', '肥', '匪', '诽', '吠', '肺', '废', '沸', '费', '芬', '酚', '吩', '氛', '分', '纷', '坟', '焚', '汾', '粉', '奋', '份', '忿', '愤', '粪', '丰', '封', '枫', '蜂', '峰', '锋', '风', '疯', '烽', '逢', '冯', '缝', '讽', '奉', '凤', '佛', '否', '夫', '敷', '肤', '孵', '扶', '拂', '辐', '幅', '氟', '符', '伏', '俘', '服', '浮', '涪', '福', '袱', '弗', '甫', '抚', '辅', '俯', '釜', '斧', '脯', '腑', '府', '腐', '赴', '副', '覆', '赋', '复', '傅', '付', '阜', '父', '腹', '负', '富', '讣', '附', '妇', '缚', '咐', '噶', '嘎', '该', '改', '概', '钙', '盖', '溉', '干', '甘', '杆', '柑', '竿', '肝', '赶', '感', '秆', '敢', '赣', '冈', '刚', '钢', '缸', '肛', '纲', '岗', '港', '杠', '篙', '皋', '高', '膏', '羔', '糕', '搞', '镐', '稿', '告', '哥', '歌', '搁', '戈', '鸽', '胳', '疙', '割', '革', '葛', '格', '蛤', '阁', '隔', '铬', '个', '各', '给', '根', '跟', '耕', '更', '庚', '羹', '埂', '耿', '梗', '工', '攻', '功', '恭', '龚', '供', '躬', '公', '宫', '弓', '巩', '汞', '拱', '贡', '共', '钩', '勾', '沟', '苟', '狗', '垢', '构', '购', '够', '辜', '菇', '咕', '箍', '估', '沽', '孤', '姑', '鼓', '古', '蛊', '骨', '谷', '股', '故', '顾', '固', '雇', '刮', '瓜', '剐', '寡', '挂', '褂', '乖', '拐', '怪', '棺', '关', '官', '冠', '观', '管', '馆', '罐', '惯', '灌', '贯', '光', '广', '逛', '瑰', '规', '圭', '硅', '归', '龟', '闺', '轨', '鬼', '诡', '癸', '桂', '柜', '跪', '贵', '刽', '辊', '滚', '棍', '锅', '郭', '国', '果', '裹', '过', '哈', '骸', '孩', '海', '氦', '亥', '害', '骇', '酣', '憨', '邯', '韩', '含', '涵', '寒', '函', '喊', '罕', '翰', '撼', '捍', '旱', '憾', '悍', '焊', '汗', '汉', '夯', '杭', '航', '壕', '嚎', '豪', '毫', '郝', '好', '耗', '号', '浩', '呵', '喝', '荷', '菏', '核', '禾', '和', '何', '合', '盒', '貉', '阂', '河', '涸', '赫', '褐', '鹤', '贺', '嘿', '黑', '痕', '很', '狠', '恨', '哼', '亨', '横', '衡', '恒', '轰', '哄', '烘', '虹', '鸿', '洪', '宏', '弘', '红', '喉', '侯', '猴', '吼', '厚', '候', '后', '呼', '乎', '忽', '瑚', '壶', '葫', '胡', '蝴', '狐', '糊', '湖', '弧', '虎', '唬', '护', '互', '沪', '户', '花', '哗', '华', '猾', '滑', '画', '划', '化', '话', '槐', '徊', '怀', '淮', '坏', '欢', '环', '桓', '还', '缓', '换', '患', '唤', '痪', '豢', '焕', '涣', '宦', '幻', '荒', '慌', '黄', '磺', '蝗', '簧', '皇', '凰', '惶', '煌', '晃', '幌', '恍', '谎', '灰', '挥', '辉', '徽', '恢', '蛔', '回', '毁', '悔', '慧', '卉', '惠', '晦', '贿', '秽', '会', '烩', '汇', '讳', '诲', '绘', '荤', '昏', '婚', '魂', '浑', '混', '豁', '活', '伙', '火', '获', '或', '惑', '霍', '货', '祸', '击', '圾', '基', '机', '畸', '稽', '积', '箕', '肌', '饥', '迹', '激', '讥', '鸡', '姬', '绩', '缉', '吉', '极', '棘', '辑', '籍', '集', '及', '急', '疾', '汲', '即', '嫉', '级', '挤', '几', '脊', '己', '蓟', '技', '冀', '季', '伎', '祭', '剂', '悸', '济', '寄', '寂', '计', '记', '既', '忌', '际', '妓', '继', '纪', '嘉', '枷', '夹', '佳', '家', '加', '荚', '颊', '贾', '甲', '钾', '假', '稼', '价', '架', '驾', '嫁', '歼', '监', '坚', '尖', '笺', '间', '煎', '兼', '肩', '艰', '奸', '缄', '茧', '检', '柬', '碱', '硷', '拣', '捡', '简', '俭', '剪', '减', '荐', '槛', '鉴', '践', '贱', '见', '键', '箭', '件', '健', '舰', '剑', '饯', '渐', '溅', '涧', '建', '僵', '姜', '将', '浆', '江', '疆', '蒋', '桨', '奖', '讲', '匠', '酱', '降', '蕉', '椒', '礁', '焦', '胶', '交', '郊', '浇', '骄', '娇', '嚼', '搅', '铰', '矫', '侥', '脚', '狡', '角', '饺', '缴', '绞', '剿', '教', '酵', '轿', '较', '叫', '窖', '揭', '接', '皆', '秸', '街', '阶', '截', '劫', '节', '桔', '杰', '捷', '睫', '竭', '洁', '结', '解', '姐', '戒', '藉', '芥', '界', '借', '介', '疥', '诫', '届', '巾', '筋', '斤', '金', '今', '津', '襟', '紧', '锦', '仅', '谨', '进', '靳', '晋', '禁', '近', '烬', '浸', '尽', '劲', '荆', '兢', '茎', '睛', '晶', '鲸', '京', '惊', '精', '粳', '经', '井', '警', '景', '颈', '静', '境', '敬', '镜', '径', '痉', '靖', '竟', '竞', '净', '炯', '窘', '揪', '究', '纠', '玖', '韭', '久', '灸', '九', '酒', '厩', '救', '旧', '臼', '舅', '咎', '就', '疚', '鞠', '拘', '狙', '疽', '居', '驹', '菊', '局', '咀', '矩', '举', '沮', '聚', '拒', '据', '巨', '具', '距', '踞', '锯', '俱', '句', '惧', '炬', '剧', '捐', '鹃', '娟', '倦', '眷', '卷', '绢', '撅', '攫', '抉', '掘', '倔', '爵', '觉', '决', '诀', '绝', '均', '菌', '钧', '军', '君', '峻', '俊', '竣', '浚', '郡', '骏', '喀', '咖', '卡', '咯', '开', '揩', '楷', '凯', '慨', '刊', '堪', '勘', '坎', '砍', '看', '康', '慷', '糠', '扛', '抗', '亢', '炕', '考', '拷', '烤', '靠', '坷', '苛', '柯', '棵', '磕', '颗', '科', '壳', '咳', '可', '渴', '克', '刻', '客', '课', '肯', '啃', '垦', '恳', '坑', '吭', '空', '恐', '孔', '控', '抠', '口', '扣', '寇', '枯', '哭', '窟', '苦', '酷', '库', '裤', '夸', '垮', '挎', '跨', '胯', '块', '筷', '侩', '快', '宽', '款', '匡', '筐', '狂', '框', '矿', '眶', '旷', '况', '亏', '盔', '岿', '窥', '葵', '奎', '魁', '傀', '馈', '愧', '溃', '坤', '昆', '捆', '困', '括', '扩', '廓', '阔', '垃', '拉', '喇', '蜡', '腊', '辣', '啦', '莱', '来', '赖', '蓝', '婪', '栏', '拦', '篮', '阑', '兰', '澜', '谰', '揽', '览', '懒', '缆', '烂', '滥', '琅', '榔', '狼', '廊', '郎', '朗', '浪', '捞', '劳', '牢', '老', '佬', '姥', '酪', '烙', '涝', '勒', '乐', '雷', '镭', '蕾', '磊', '累', '儡', '垒', '擂', '肋', '类', '泪', '棱', '楞', '冷', '厘', '梨', '犁', '黎', '篱', '狸', '离', '漓', '理', '李', '里', '鲤', '礼', '莉', '荔', '吏', '栗', '丽', '厉', '励', '砾', '历', '利', '傈', '例', '俐', '痢', '立', '粒', '沥', '隶', '力', '璃', '哩', '俩', '联', '莲', '连', '镰', '廉', '怜', '涟', '帘', '敛', '脸', '链', '恋', '炼', '练', '粮', '凉', '梁', '粱', '良', '两', '辆', '量', '晾', '亮', '谅', '撩', '聊', '僚', '疗', '燎', '寥', '辽', '潦', '了', '撂', '镣', '廖', '料', '列', '裂', '烈', '劣', '猎', '琳', '林', '磷', '霖', '临', '邻', '鳞', '淋', '凛', '赁', '吝', '拎', '玲', '菱', '零', '龄', '铃', '伶', '羚', '凌', '灵', '陵', '岭', '领', '另', '令', '溜', '琉', '榴', '硫', '馏', '留', '刘', '瘤', '流', '柳', '六', '龙', '聋', '咙', '笼', '窿', '隆', '垄', '拢', '陇', '楼', '娄', '搂', '篓', '漏', '陋', '芦', '卢', '颅', '庐', '炉', '掳', '卤', '虏', '鲁', '麓', '碌', '露', '路', '赂', '鹿', '潞', '禄', '录', '陆', '戮', '驴', '吕', '铝', '侣', '旅', '履', '屡', '缕', '虑', '氯', '律', '率', '滤', '绿', '峦', '挛', '孪', '滦', '卵', '乱', '掠', '略', '抡', '轮', '伦', '仑', '沦', '纶', '论', '萝', '螺', '罗', '逻', '锣', '箩', '骡', '裸', '落', '洛', '骆', '络', '妈', '麻', '玛', '码', '蚂', '马', '骂', '嘛', '吗', '埋', '买', '麦', '卖', '迈', '脉', '瞒', '馒', '蛮', '满', '蔓', '曼', '慢', '漫', '谩', '芒', '茫', '盲', '氓', '忙', '莽', '猫', '茅', '锚', '毛', '矛', '铆', '卯', '茂', '冒', '帽', '貌', '贸', '么', '玫', '枚', '梅', '酶', '霉', '煤', '没', '眉', '媒', '镁', '每', '美', '昧', '寐', '妹', '媚', '门', '闷', '们', '萌', '蒙', '檬', '盟', '锰', '猛', '梦', '孟', '眯', '醚', '靡', '糜', '迷', '谜', '弥', '米', '秘', '觅', '泌', '蜜', '密', '幂', '棉', '眠', '绵', '冕', '免', '勉', '娩', '缅', '面', '苗', '描', '瞄', '藐', '秒', '渺', '庙', '妙', '蔑', '灭', '民', '抿', '皿', '敏', '悯', '闽', '明', '螟', '鸣', '铭', '名', '命', '谬', '摸', '摹', '蘑', '模', '膜', '磨', '摩', '魔', '抹', '末', '莫', '墨', '默', '沫', '漠', '寞', '陌', '谋', '牟', '某', '拇', '牡', '亩', '姆', '母', '墓', '暮', '幕', '募', '慕', '木', '目', '睦', '牧', '穆', '拿', '哪', '呐', '钠', '那', '娜', '纳', '氖', '乃', '奶', '耐', '奈', '南', '男', '难', '囊', '挠', '脑', '恼', '闹', '淖', '呢', '馁', '内', '嫩', '能', '妮', '霓', '倪', '泥', '尼', '拟', '你', '匿', '腻', '逆', '溺', '蔫', '拈', '年', '碾', '撵', '捻', '念', '娘', '酿', '鸟', '尿', '捏', '聂', '孽', '啮', '镊', '镍', '涅', '您', '柠', '狞', '凝', '宁', '拧', '泞', '牛', '扭', '钮', '纽', '脓', '浓', '农', '弄', '奴', '努', '怒', '女', '暖', '虐', '疟', '挪', '懦', '糯', '诺', '哦', '欧', '鸥', '殴', '藕', '呕', '偶', '沤', '啪', '趴', '爬', '帕', '怕', '琶', '拍', '排', '牌', '徘', '湃', '派', '攀', '潘', '盘', '磐', '盼', '畔', '判', '叛', '乓', '庞', '旁', '耪', '胖', '抛', '咆', '刨', '炮', '袍', '跑', '泡', '呸', '胚', '培', '裴', '赔', '陪', '配', '佩', '沛', '喷', '盆', '砰', '抨', '烹', '澎', '彭', '蓬', '棚', '硼', '篷', '膨', '朋', '鹏', '捧', '碰', '坯', '砒', '霹', '批', '披', '劈', '琵', '毗', '啤', '脾', '疲', '皮', '匹', '痞', '僻', '屁', '譬', '篇', '偏', '片', '骗', '飘', '漂', '瓢', '票', '撇', '瞥', '拼', '频', '贫', '品', '聘', '乒', '坪', '苹', '萍', '平', '凭', '瓶', '评', '屏', '坡', '泼', '颇', '婆', '破', '魄', '迫', '粕', '剖', '扑', '铺', '仆', '莆', '葡', '菩', '蒲', '埔', '朴', '圃', '普', '浦', '谱', '曝', '瀑', '期', '欺', '栖', '戚', '妻', '七', '凄', '漆', '柒', '沏', '其', '棋', '奇', '歧', '畦', '崎', '脐', '齐', '旗', '祈', '祁', '骑', '起', '岂', '乞', '企', '启', '契', '砌', '器', '气', '迄', '弃', '汽', '泣', '讫', '掐', '恰', '洽', '牵', '扦', '钎', '铅', '千', '迁', '签', '仟', '谦', '乾', '黔', '钱', '钳', '前', '潜', '遣', '浅', '谴', '堑', '嵌', '欠', '歉', '枪', '呛', '腔', '羌', '墙', '蔷', '强', '抢', '橇', '锹', '敲', '悄', '桥', '瞧', '乔', '侨', '巧', '鞘', '撬', '翘', '峭', '俏', '窍', '切', '茄', '且', '怯', '窃', '钦', '侵', '亲', '秦', '琴', '勤', '芹', '擒', '禽', '寝', '沁', '青', '轻', '氢', '倾', '卿', '清', '擎', '晴', '氰', '情', '顷', '请', '庆', '琼', '穷', '秋', '丘', '邱', '球', '求', '囚', '酋', '泅', '趋', '区', '蛆', '曲', '躯', '屈', '驱', '渠', '取', '娶', '龋', '趣', '去', '圈', '颧', '权', '醛', '泉', '全', '痊', '拳', '犬', '券', '劝', '缺', '炔', '瘸', '却', '鹊', '榷', '确', '雀', '裙', '群', '然', '燃', '冉', '染', '瓤', '壤', '攘', '嚷', '让', '饶', '扰', '绕', '惹', '热', '壬', '仁', '人', '忍', '韧', '任', '认', '刃', '妊', '纫', '扔', '仍', '日', '戎', '茸', '蓉', '荣', '融', '熔', '溶', '容', '绒', '冗', '揉', '柔', '肉', '茹', '蠕', '儒', '孺', '如', '辱', '乳', '汝', '入', '褥', '软', '阮', '蕊', '瑞', '锐', '闰', '润', '若', '弱', '撒', '洒', '萨', '腮', '鳃', '塞', '赛', '三', '叁', '伞', '散', '桑', '嗓', '丧', '搔', '骚', '扫', '嫂', '瑟', '色', '涩', '森', '僧', '莎', '砂', '杀', '刹', '沙', '纱', '傻', '啥', '煞', '筛', '晒', '珊', '苫', '杉', '山', '删', '煽', '衫', '闪', '陕', '擅', '赡', '膳', '善', '汕', '扇', '缮', '墒', '伤', '商', '赏', '晌', '上', '尚', '裳', '梢', '捎', '稍', '烧', '芍', '勺', '韶', '少', '哨', '邵', '绍', '奢', '赊', '蛇', '舌', '舍', '赦', '摄', '射', '慑', '涉', '社', '设', '砷', '申', '呻', '伸', '身', '深', '娠', '绅', '神', '沈', '审', '婶', '甚', '肾', '慎', '渗', '声', '生', '甥', '牲', '升', '绳', '省', '盛', '剩', '胜', '圣', '师', '失', '狮', '施', '湿', '诗', '尸', '虱', '十', '石', '拾', '时', '什', '食', '蚀', '实', '识', '史', '矢', '使', '屎', '驶', '始', '式', '示', '士', '世', '柿', '事', '拭', '誓', '逝', '势', '是', '嗜', '噬', '适', '仕', '侍', '释', '饰', '氏', '市', '恃', '室', '视', '试', '收', '手', '首', '守', '寿', '授', '售', '受', '瘦', '兽', '蔬', '枢', '梳', '殊', '抒', '输', '叔', '舒', '淑', '疏', '书', '赎', '孰', '熟', '薯', '暑', '曙', '署', '蜀', '黍', '鼠', '属', '术', '述', '树', '束', '戍', '竖', '墅', '庶', '数', '漱', '恕', '刷', '耍', '摔', '衰', '甩', '帅', '栓', '拴', '霜', '双', '爽', '谁', '水', '睡', '税', '吮', '瞬', '顺', '舜', '说', '硕', '朔', '烁', '斯', '撕', '嘶', '思', '私', '司', '丝', '死', '肆', '寺', '嗣', '四', '伺', '似', '饲', '巳', '松', '耸', '怂', '颂', '送', '宋', '讼', '诵', '搜', '艘', '擞', '嗽', '苏', '酥', '俗', '素', '速', '粟', '僳', '塑', '溯', '宿', '诉', '肃', '酸', '蒜', '算', '虽', '隋', '随', '绥', '髓', '碎', '岁', '穗', '遂', '隧', '祟', '孙', '损', '笋', '蓑', '梭', '唆', '缩', '琐', '索', '锁', '所', '塌', '他', '它', '她', '塔', '獭', '挞', '蹋', '踏', '胎', '苔', '抬', '台', '泰', '酞', '太', '态', '汰', '坍', '摊', '贪', '瘫', '滩', '坛', '檀', '痰', '潭', '谭', '谈', '坦', '毯', '袒', '碳', '探', '叹', '炭', '汤', '塘', '搪', '堂', '棠', '膛', '唐', '糖', '倘', '躺', '淌', '趟', '烫', '掏', '涛', '滔', '绦', '萄', '桃', '逃', '淘', '陶', '讨', '套', '特', '藤', '腾', '疼', '誊', '梯', '剔', '踢', '锑', '提', '题', '蹄', '啼', '体', '替', '嚏', '惕', '涕', '剃', '屉', '天', '添', '填', '田', '甜', '恬', '舔', '腆', '挑', '条', '迢', '眺', '跳', '贴', '铁', '帖', '厅', '听', '烃', '汀', '廷', '停', '亭', '庭', '挺', '艇', '通', '桐', '酮', '瞳', '同', '铜', '彤', '童', '桶', '捅', '筒', '统', '痛', '偷', '投', '头', '透', '凸', '秃', '突', '图', '徒', '途', '涂', '屠', '土', '吐', '兔', '湍', '团', '推', '颓', '腿', '蜕', '褪', '退', '吞', '屯', '臀', '拖', '托', '脱', '鸵', '陀', '驮', '驼', '椭', '妥', '拓', '唾', '挖', '哇', '蛙', '洼', '娃', '瓦', '袜', '歪', '外', '豌', '弯', '湾', '玩', '顽', '丸', '烷', '完', '碗', '挽', '晚', '皖', '惋', '宛', '婉', '万', '腕', '汪', '王', '亡', '枉', '网', '往', '旺', '望', '忘', '妄', '威', '巍', '微', '危', '韦', '违', '桅', '围', '唯', '惟', '为', '潍', '维', '苇', '萎', '委', '伟', '伪', '尾', '纬', '未', '蔚', '味', '畏', '胃', '喂', '魏', '位', '渭', '谓', '尉', '慰', '卫', '瘟', '温', '蚊', '文', '闻', '纹', '吻', '稳', '紊', '问', '嗡', '翁', '瓮', '挝', '蜗', '涡', '窝', '我', '斡', '卧', '握', '沃', '巫', '呜', '钨', '乌', '污', '诬', '屋', '无', '芜', '梧', '吾', '吴', '毋', '武', '五', '捂', '午', '舞', '伍', '侮', '坞', '戊', '雾', '晤', '物', '勿', '务', '悟', '误', '昔', '熙', '析', '西', '硒', '矽', '晰', '嘻', '吸', '锡', '牺', '稀', '息', '希', '悉', '膝', '夕', '惜', '熄', '烯', '溪', '汐', '犀', '檄', '袭', '席', '习', '媳', '喜', '铣', '洗', '系', '隙', '戏', '细', '瞎', '虾', '匣', '霞', '辖', '暇', '峡', '侠', '狭', '下', '厦', '夏', '吓', '掀', '锨', '先', '仙', '鲜', '纤', '咸', '贤', '衔', '舷', '闲', '涎', '弦', '嫌', '显', '险', '现', '献', '县', '腺', '馅', '羡', '宪', '陷', '限', '线', '相', '厢', '镶', '香', '箱', '襄', '湘', '乡', '翔', '祥', '详', '想', '响', '享', '项', '巷', '橡', '像', '向', '象', '萧', '硝', '霄', '削', '哮', '嚣', '销', '消', '宵', '淆', '晓', '小', '孝', '校', '肖', '啸', '笑', '效', '楔', '些', '歇', '蝎', '鞋', '协', '挟', '携', '邪', '斜', '胁', '谐', '写', '械', '卸', '蟹', '懈', '泄', '泻', '谢', '屑', '薪', '芯', '锌', '欣', '辛', '新', '忻', '心', '信', '衅', '星', '腥', '猩', '惺', '兴', '刑', '型', '形', '邢', '行', '醒', '幸', '杏', '性', '姓', '兄', '凶', '胸', '匈', '汹', '雄', '熊', '休', '修', '羞', '朽', '嗅', '锈', '秀', '袖', '绣', '墟', '戌', '需', '虚', '嘘', '须', '徐', '许', '蓄', '酗', '叙', '旭', '序', '畜', '恤', '絮', '婿', '绪', '续', '轩', '喧', '宣', '悬', '旋', '玄', '选', '癣', '眩', '绚', '靴', '薛', '学', '穴', '雪', '血', '勋', '熏', '循', '旬', '询', '寻', '驯', '巡', '殉', '汛', '训', '讯', '逊', '迅', '压', '押', '鸦', '鸭', '呀', '丫', '芽', '牙', '蚜', '崖', '衙', '涯', '雅', '哑', '亚', '讶', '焉', '咽', '阉', '烟', '淹', '盐', '严', '研', '蜒', '岩', '延', '言', '颜', '阎', '炎', '沿', '奄', '掩', '眼', '衍', '演', '艳', '堰', '燕', '厌', '砚', '雁', '唁', '彦', '焰', '宴', '谚', '验', '殃', '央', '鸯', '秧', '杨', '扬', '佯', '疡', '羊', '洋', '阳', '氧', '仰', '痒', '养', '样', '漾', '邀', '腰', '妖', '瑶', '摇', '尧', '遥', '窑', '谣', '姚', '咬', '舀', '药', '要', '耀', '椰', '噎', '耶', '爷', '野', '冶', '也', '页', '掖', '业', '叶', '曳', '腋', '夜', '液', '一', '壹', '医', '揖', '铱', '依', '伊', '衣', '颐', '夷', '遗', '移', '仪', '胰', '疑', '沂', '宜', '姨', '彝', '椅', '蚁', '倚', '已', '乙', '矣', '以', '艺', '抑', '易', '邑', '屹', '亿', '役', '臆', '逸', '肄', '疫', '亦', '裔', '意', '毅', '忆', '义', '益', '溢', '诣', '议', '谊', '译', '异', '翼', '翌', '绎', '茵', '荫', '因', '殷', '音', '阴', '姻', '吟', '银', '淫', '寅', '饮', '尹', '引', '隐', '印', '英', '樱', '婴', '鹰', '应', '缨', '莹', '萤', '营', '荧', '蝇', '迎', '赢', '盈', '影', '颖', '硬', '映', '哟', '拥', '佣', '臃', '痈', '庸', '雍', '踊', '蛹', '咏', '泳', '涌', '永', '恿', '勇', '用', '幽', '优', '悠', '忧', '尤', '由', '邮', '铀', '犹', '油', '游', '酉', '有', '友', '右', '佑', '釉', '诱', '又', '幼', '迂', '淤', '于', '盂', '榆', '虞', '愚', '舆', '余', '俞', '逾', '鱼', '愉', '渝', '渔', '隅', '予', '娱', '雨', '与', '屿', '禹', '宇', '语', '羽', '玉', '域', '芋', '郁', '吁', '遇', '喻', '峪', '御', '愈', '欲', '狱', '育', '誉', '浴', '寓', '裕', '预', '豫', '驭', '鸳', '渊', '冤', '元', '垣', '袁', '原', '援', '辕', '园', '员', '圆', '猿', '源', '缘', '远', '苑', '愿', '怨', '院', '曰', '约', '越', '跃', '钥', '岳', '粤', '月', '悦', '阅', '耘', '云', '郧', '匀', '陨', '允', '运', '蕴', '酝', '晕', '韵', '孕', '匝', '砸', '杂', '栽', '哉', '灾', '宰', '载', '再', '在', '咱', '攒', '暂', '赞', '赃', '脏', '葬', '遭', '糟', '凿', '藻', '枣', '早', '澡', '蚤', '躁', '噪', '造', '皂', '灶', '燥', '责', '择', '则', '泽', '贼', '怎', '增', '憎', '曾', '赠', '扎', '喳', '渣', '札', '轧', '铡', '闸', '眨', '栅', '榨', '咋', '乍', '炸', '诈', '摘', '斋', '宅', '窄', '债', '寨', '瞻', '毡', '詹', '粘', '沾', '盏', '斩', '辗', '崭', '展', '蘸', '栈', '占', '战', '站', '湛', '绽', '樟', '章', '彰', '漳', '张', '掌', '涨', '杖', '丈', '帐', '账', '仗', '胀', '瘴', '障', '招', '昭', '找', '沼', '赵', '照', '罩', '兆', '肇', '召', '遮', '折', '哲', '蛰', '辙', '者', '锗', '蔗', '这', '浙', '珍', '斟', '真', '甄', '砧', '臻', '贞', '针', '侦', '枕', '疹', '诊', '震', '振', '镇', '阵', '蒸', '挣', '睁', '征', '狰', '争', '怔', '整', '拯', '正', '政', '帧', '症', '郑', '证', '芝', '枝', '支', '吱', '蜘', '知', '肢', '脂', '汁', '之', '织', '职', '直', '植', '殖', '执', '值', '侄', '址', '指', '止', '趾', '只', '旨', '纸', '志', '挚', '掷', '至', '致', '置', '帜', '峙', '制', '智', '秩', '稚', '质', '炙', '痔', '滞', '治', '窒', '中', '盅', '忠', '钟', '衷', '终', '种', '肿', '重', '仲', '众', '舟', '周', '州', '洲', '诌', '粥', '轴', '肘', '帚', '咒', '皱', '宙', '昼', '骤', '珠', '株', '蛛', '朱', '猪', '诸', '诛', '逐', '竹', '烛', '煮', '拄', '瞩', '嘱', '主', '著', '柱', '助', '蛀', '贮', '铸', '筑', '住', '注', '祝', '驻', '抓', '爪', '拽', '专', '砖', '转', '撰', '赚', '篆', '桩', '庄', '装', '妆', '撞', '壮', '状', '椎', '锥', '追', '赘', '坠', '缀', '谆', '准', '捉', '拙', '卓', '桌', '琢', '茁', '酌', '啄', '着', '灼', '浊', '兹', '咨', '资', '姿', '滋', '淄', '孜', '紫', '仔', '籽', '滓', '子', '自', '渍', '字', '鬃', '棕', '踪', '宗', '综', '总', '纵', '邹', '走', '奏', '揍', '租', '足', '卒', '族', '祖', '诅', '阻', '组', '钻', '纂', '嘴', '醉', '最', '罪', '尊', '遵', '昨', '左', '佐', '柞', '做', '作', '坐', '座', '亍', '丌', '兀', '丐', '廿', '卅', '丕', '亘', '丞', '鬲', '孬', '噩', '丨', '禺', '丿', '匕', '乇', '夭', '爻', '卮', '氐', '囟', '胤', '馗', '毓', '睾', '鼗', '丶', '亟', '鼐', '乜', '乩', '亓', '芈', '孛', '啬', '嘏', '仄', '厍', '厝', '厣', '厥', '厮', '靥', '赝', '匚', '叵', '匦', '匮', '匾', '赜', '卦', '卣', '刂', '刈', '刎', '刭', '刳', '刿', '剀', '剌', '剞', '剡', '剜', '蒯', '剽', '劂', '劁', '劐', '劓', '冂', '罔', '亻', '仃', '仉', '仂', '仨', '仡', '仫', '仞', '伛', '仳', '伢', '佤', '仵', '伥', '伧', '伉', '伫', '佞', '佧', '攸', '佚', '佝', '佟', '佗', '伲', '伽', '佶', '佴', '侑', '侉', '侃', '侏', '佾', '佻', '侪', '佼', '侬', '侔', '俦', '俨', '俪', '俅', '俚', '俣', '俜', '俑', '俟', '俸', '倩', '偌', '俳', '倬', '倏', '倮', '倭', '俾', '倜', '倌', '倥', '倨', '偾', '偃', '偕', '偈', '偎', '偬', '偻', '傥', '傧', '傩', '傺', '僖', '儆', '僭', '僬', '僦', '僮', '儇', '儋', '仝', '氽', '佘', '佥', '俎', '龠', '汆', '籴', '兮', '巽', '黉', '馘', '冁', '夔', '勹', '匍', '訇', '匐', '凫', '夙', '兕', '亠', '兖', '亳', '衮', '袤', '亵', '脔', '裒', '禀', '嬴', '蠃', '羸', '冫', '冱', '冽', '冼', '凇', '冖', '冢', '冥', '讠', '讦', '讧', '讪', '讴', '讵', '讷', '诂', '诃', '诋', '诏', '诎', '诒', '诓', '诔', '诖', '诘', '诙', '诜', '诟', '诠', '诤', '诨', '诩', '诮', '诰', '诳', '诶', '诹', '诼', '诿', '谀', '谂', '谄', '谇', '谌', '谏', '谑', '谒', '谔', '谕', '谖', '谙', '谛', '谘', '谝', '谟', '谠', '谡', '谥', '谧', '谪', '谫', '谮', '谯', '谲', '谳', '谵', '谶', '卩', '卺', '阝', '阢', '阡', '阱', '阪', '阽', '阼', '陂', '陉', '陔', '陟', '陧', '陬', '陲', '陴', '隈', '隍', '隗', '隰', '邗', '邛', '邝', '邙', '邬', '邡', '邴', '邳', '邶', '邺', '邸', '邰', '郏', '郅', '邾', '郐', '郄', '郇', '郓', '郦', '郢', '郜', '郗', '郛', '郫', '郯', '郾', '鄄', '鄢', '鄞', '鄣', '鄱', '鄯', '鄹', '酃', '酆', '刍', '奂', '劢', '劬', '劭', '劾', '哿', '勐', '勖', '勰', '叟', '燮', '矍', '廴', '凵', '凼', '鬯', '厶', '弁', '畚', '巯', '坌', '垩', '垡', '塾', '墼', '壅', '壑', '圩', '圬', '圪', '圳', '圹', '圮', '圯', '坜', '圻', '坂', '坩', '垅', '坫', '垆', '坼', '坻', '坨', '坭', '坶', '坳', '垭', '垤', '垌', '垲', '埏', '垧', '垴', '垓', '垠', '埕', '埘', '埚', '埙', '埒', '垸', '埴', '埯', '埸', '埤', '埝', '堋', '堍', '埽', '埭', '堀', '堞', '堙', '塄', '堠', '塥', '塬', '墁', '墉', '墚', '墀', '馨', '鼙', '懿', '艹', '艽', '艿', '芏', '芊', '芨', '芄', '芎', '芑', '芗', '芙', '芫', '芸', '芾', '芰', '苈', '苊', '苣', '芘', '芷', '芮', '苋', '苌', '苁', '芩', '芴', '芡', '芪', '芟', '苄', '苎', '芤', '苡', '茉', '苷', '苤', '茏', '茇', '苜', '苴', '苒', '苘', '茌', '苻', '苓', '茑', '茚', '茆', '茔', '茕', '苠', '苕', '茜', '荑', '荛', '荜', '茈', '莒', '茼', '茴', '茱', '莛', '荞', '茯', '荏', '荇', '荃', '荟', '荀', '茗', '荠', '茭', '茺', '茳', '荦', '荥', '荨', '茛', '荩', '荬', '荪', '荭', '荮', '莰', '荸', '莳', '莴', '莠', '莪', '莓', '莜', '莅', '荼', '莶', '莩', '荽', '莸', '荻', '莘', '莞', '莨', '莺', '莼', '菁', '萁', '菥', '菘', '堇', '萘', '萋', '菝', '菽', '菖', '萜', '萸', '萑', '萆', '菔', '菟', '萏', '萃', '菸', '菹', '菪', '菅', '菀', '萦', '菰', '菡', '葜', '葑', '葚', '葙', '葳', '蒇', '蒈', '葺', '蒉', '葸', '萼', '葆', '葩', '葶', '蒌', '蒎', '萱', '葭', '蓁', '蓍', '蓐', '蓦', '蒽', '蓓', '蓊', '蒿', '蒺', '蓠', '蒡', '蒹', '蒴', '蒗', '蓥', '蓣', '蔌', '甍', '蔸', '蓰', '蔹', '蔟', '蔺', '蕖', '蔻', '蓿', '蓼', '蕙', '蕈', '蕨', '蕤', '蕞', '蕺', '瞢', '蕃', '蕲', '蕻', '薤', '薨', '薇', '薏', '蕹', '薮', '薜', '薅', '薹', '薷', '薰', '藓', '藁', '藜', '藿', '蘧', '蘅', '蘩', '蘖', '蘼', '廾', '弈', '夼', '奁', '耷', '奕', '奚', '奘', '匏', '尢', '尥', '尬', '尴', '扌', '扪', '抟', '抻', '拊', '拚', '拗', '拮', '挢', '拶', '挹', '捋', '捃', '掭', '揶', '捱', '捺', '掎', '掴', '捭', '掬', '掊', '捩', '掮', '掼', '揲', '揸', '揠', '揿', '揄', '揞', '揎', '摒', '揆', '掾', '摅', '摁', '搋', '搛', '搠', '搌', '搦', '搡', '摞', '撄', '摭', '撖', '摺', '撷', '撸', '撙', '撺', '擀', '擐', '擗', '擤', '擢', '攉', '攥', '攮', '弋', '忒', '甙', '弑', '卟', '叱', '叽', '叩', '叨', '叻', '吒', '吖', '吆', '呋', '呒', '呓', '呔', '呖', '呃', '吡', '呗', '呙', '吣', '吲', '咂', '咔', '呷', '呱', '呤', '咚', '咛', '咄', '呶', '呦', '咝', '哐', '咭', '哂', '咴', '哒', '咧', '咦', '哓', '哔', '呲', '咣', '哕', '咻', '咿', '哌', '哙', '哚', '哜', '咩', '咪', '咤', '哝', '哏', '哞', '唛', '哧', '唠', '哽', '唔', '哳', '唢', '唣', '唏', '唑', '唧', '唪', '啧', '喏', '喵', '啉', '啭', '啁', '啕', '唿', '啐', '唼', '唷', '啖', '啵', '啶', '啷', '唳', '唰', '啜', '喋', '嗒', '喃', '喱', '喹', '喈', '喁', '喟', '啾', '嗖', '喑', '啻', '嗟', '喽', '喾', '喔', '喙', '嗪', '嗷', '嗉', '嘟', '嗑', '嗫', '嗬', '嗔', '嗦', '嗝', '嗄', '嗯', '嗥', '嗲', '嗳', '嗌', '嗍', '嗨', '嗵', '嗤', '辔', '嘞', '嘈', '嘌', '嘁', '嘤', '嘣', '嗾', '嘀', '嘧', '嘭', '噘', '嘹', '噗', '嘬', '噍', '噢', '噙', '噜', '噌', '噔', '嚆', '噤', '噱', '噫', '噻', '噼', '嚅', '嚓', '嚯', '囔', '囗', '囝', '囡', '囵', '囫', '囹', '囿', '圄', '圊', '圉', '圜', '帏', '帙', '帔', '帑', '帱', '帻', '帼', '帷', '幄', '幔', '幛', '幞', '幡', '岌', '屺', '岍', '岐', '岖', '岈', '岘', '岙', '岑', '岚', '岜', '岵', '岢', '岽', '岬', '岫', '岱', '岣', '峁', '岷', '峄', '峒', '峤', '峋', '峥', '崂', '崃', '崧', '崦', '崮', '崤', '崞', '崆', '崛', '嵘', '崾', '崴', '崽', '嵬', '嵛', '嵯', '嵝', '嵫', '嵋', '嵊', '嵩', '嵴', '嶂', '嶙', '嶝', '豳', '嶷', '巅', '彳', '彷', '徂', '徇', '徉', '後', '徕', '徙', '徜', '徨', '徭', '徵', '徼', '衢', '彡', '犭', '犰', '犴', '犷', '犸', '狃', '狁', '狎', '狍', '狒', '狨', '狯', '狩', '狲', '狴', '狷', '猁', '狳', '猃', '狺', '狻', '猗', '猓', '猡', '猊', '猞', '猝', '猕', '猢', '猹', '猥', '猬', '猸', '猱', '獐', '獍', '獗', '獠', '獬', '獯', '獾', '舛', '夥', '飧', '夤', '夂', '饣', '饧', '饨', '饩', '饪', '饫', '饬', '饴', '饷', '饽', '馀', '馄', '馇', '馊', '馍', '馐', '馑', '馓', '馔', '馕', '庀', '庑', '庋', '庖', '庥', '庠', '庹', '庵', '庾', '庳', '赓', '廒', '廑', '廛', '廨', '廪', '膺', '忄', '忉', '忖', '忏', '怃', '忮', '怄', '忡', '忤', '忾', '怅', '怆', '忪', '忭', '忸', '怙', '怵', '怦', '怛', '怏', '怍', '怩', '怫', '怊', '怿', '怡', '恸', '恹', '恻', '恺', '恂', '恪', '恽', '悖', '悚', '悭', '悝', '悃', '悒', '悌', '悛', '惬', '悻', '悱', '惝', '惘', '惆', '惚', '悴', '愠', '愦', '愕', '愣', '惴', '愀', '愎', '愫', '慊', '慵', '憬', '憔', '憧', '憷', '懔', '懵', '忝', '隳', '闩', '闫', '闱', '闳', '闵', '闶', '闼', '闾', '阃', '阄', '阆', '阈', '阊', '阋', '阌', '阍', '阏', '阒', '阕', '阖', '阗', '阙', '阚', '丬', '爿', '戕', '氵', '汔', '汜', '汊', '沣', '沅', '沐', '沔', '沌', '汨', '汩', '汴', '汶', '沆', '沩', '泐', '泔', '沭', '泷', '泸', '泱', '泗', '沲', '泠', '泖', '泺', '泫', '泮', '沱', '泓', '泯', '泾', '洹', '洧', '洌', '浃', '浈', '洇', '洄', '洙', '洎', '洫', '浍', '洮', '洵', '洚', '浏', '浒', '浔', '洳', '涑', '浯', '涞', '涠', '浞', '涓', '涔', '浜', '浠', '浼', '浣', '渚', '淇', '淅', '淞', '渎', '涿', '淠', '渑', '淦', '淝', '淙', '渖', '涫', '渌', '涮', '渫', '湮', '湎', '湫', '溲', '湟', '溆', '湓', '湔', '渲', '渥', '湄', '滟', '溱', '溘', '滠', '漭', '滢', '溥', '溧', '溽', '溻', '溷', '滗', '溴', '滏', '溏', '滂', '溟', '潢', '潆', '潇', '漤', '漕', '滹', '漯', '漶', '潋', '潴', '漪', '漉', '漩', '澉', '澍', '澌', '潸', '潲', '潼', '潺', '濑', '濉', '澧', '澹', '澶', '濂', '濡', '濮', '濞', '濠', '濯', '瀚', '瀣', '瀛', '瀹', '瀵', '灏', '灞', '宀', '宄', '宕', '宓', '宥', '宸', '甯', '骞', '搴', '寤', '寮', '褰', '寰', '蹇', '謇', '辶', '迓', '迕', '迥', '迮', '迤', '迩', '迦', '迳', '迨', '逅', '逄', '逋', '逦', '逑', '逍', '逖', '逡', '逵', '逶', '逭', '逯', '遄', '遑', '遒', '遐', '遨', '遘', '遢', '遛', '暹', '遴', '遽', '邂', '邈', '邃', '邋', '彐', '彗', '彖', '彘', '尻', '咫', '屐', '屙', '孱', '屣', '屦', '羼', '弪', '弩', '弭', '艴', '弼', '鬻', '屮', '妁', '妃', '妍', '妩', '妪', '妣', '妗', '姊', '妫', '妞', '妤', '姒', '妲', '妯', '姗', '妾', '娅', '娆', '姝', '娈', '姣', '姘', '姹', '娌', '娉', '娲', '娴', '娑', '娣', '娓', '婀', '婧', '婊', '婕', '娼', '婢', '婵', '胬', '媪', '媛', '婷', '婺', '媾', '嫫', '媲', '嫒', '嫔', '媸', '嫠', '嫣', '嫱', '嫖', '嫦', '嫘', '嫜', '嬉', '嬗', '嬖', '嬲', '嬷', '孀', '尕', '尜', '孚', '孥', '孳', '孑', '孓', '孢', '驵', '驷', '驸', '驺', '驿', '驽', '骀', '骁', '骅', '骈', '骊', '骐', '骒', '骓', '骖', '骘', '骛', '骜', '骝', '骟', '骠', '骢', '骣', '骥', '骧', '纟', '纡', '纣', '纥', '纨', '纩', '纭', '纰', '纾', '绀', '绁', '绂', '绉', '绋', '绌', '绐', '绔', '绗', '绛', '绠', '绡', '绨', '绫', '绮', '绯', '绱', '绲', '缍', '绶', '绺', '绻', '绾', '缁', '缂', '缃', '缇', '缈', '缋', '缌', '缏', '缑', '缒', '缗', '缙', '缜', '缛', '缟', '缡', '缢', '缣', '缤', '缥', '缦', '缧', '缪', '缫', '缬', '缭', '缯', '缰', '缱', '缲', '缳', '缵', '幺', '畿', '巛', '甾', '邕', '玎', '玑', '玮', '玢', '玟', '珏', '珂', '珑', '玷', '玳', '珀', '珉', '珈', '珥', '珙', '顼', '琊', '珩', '珧', '珞', '玺', '珲', '琏', '琪', '瑛', '琦', '琥', '琨', '琰', '琮', '琬', '琛', '琚', '瑁', '瑜', '瑗', '瑕', '瑙', '瑷', '瑭', '瑾', '璜', '璎', '璀', '璁', '璇', '璋', '璞', '璨', '璩', '璐', '璧', '瓒', '璺', '韪', '韫', '韬', '杌', '杓', '杞', '杈', '杩', '枥', '枇', '杪', '杳', '枘', '枧', '杵', '枨', '枞', '枭', '枋', '杷', '杼', '柰', '栉', '柘', '栊', '柩', '枰', '栌', '柙', '枵', '柚', '枳', '柝', '栀', '柃', '枸', '柢', '栎', '柁', '柽', '栲', '栳', '桠', '桡', '桎', '桢', '桄', '桤', '梃', '栝', '桕', '桦', '桁', '桧', '桀', '栾', '桊', '桉', '栩', '梵', '梏', '桴', '桷', '梓', '桫', '棂', '楮', '棼', '椟', '椠', '棹', '椤', '棰', '椋', '椁', '楗', '棣', '椐', '楱', '椹', '楠', '楂', '楝', '榄', '楫', '榀', '榘', '楸', '椴', '槌', '榇', '榈', '槎', '榉', '楦', '楣', '楹', '榛', '榧', '榻', '榫', '榭', '槔', '榱', '槁', '槊', '槟', '榕', '槠', '榍', '槿', '樯', '槭', '樗', '樘', '橥', '槲', '橄', '樾', '檠', '橐', '橛', '樵', '檎', '橹', '樽', '樨', '橘', '橼', '檑', '檐', '檩', '檗', '檫', '猷', '獒', '殁', '殂', '殇', '殄', '殒', '殓', '殍', '殚', '殛', '殡', '殪', '轫', '轭', '轱', '轲', '轳', '轵', '轶', '轸', '轷', '轹', '轺', '轼', '轾', '辁', '辂', '辄', '辇', '辋', '辍', '辎', '辏', '辘', '辚', '軎', '戋', '戗', '戛', '戟', '戢', '戡', '戥', '戤', '戬', '臧', '瓯', '瓴', '瓿', '甏', '甑', '甓', '攴', '旮', '旯', '旰', '昊', '昙', '杲', '昃', '昕', '昀', '炅', '曷', '昝', '昴', '昱', '昶', '昵', '耆', '晟', '晔', '晁', '晏', '晖', '晡', '晗', '晷', '暄', '暌', '暧', '暝', '暾', '曛', '曜', '曦', '曩', '贲', '贳', '贶', '贻', '贽', '赀', '赅', '赆', '赈', '赉', '赇', '赍', '赕', '赙', '觇', '觊', '觋', '觌', '觎', '觏', '觐', '觑', '牮', '犟', '牝', '牦', '牯', '牾', '牿', '犄', '犋', '犍', '犏', '犒', '挈', '挲', '掰', '搿', '擘', '耄', '毪', '毳', '毽', '毵', '毹', '氅', '氇', '氆', '氍', '氕', '氘', '氙', '氚', '氡', '氩', '氤', '氪', '氲', '攵', '敕', '敫', '牍', '牒', '牖', '爰', '虢', '刖', '肟', '肜', '肓', '肼', '朊', '肽', '肱', '肫', '肭', '肴', '肷', '胧', '胨', '胩', '胪', '胛', '胂', '胄', '胙', '胍', '胗', '朐', '胝', '胫', '胱', '胴', '胭', '脍', '脎', '胲', '胼', '朕', '脒', '豚', '脶', '脞', '脬', '脘', '脲', '腈', '腌', '腓', '腴', '腙', '腚', '腱', '腠', '腩', '腼', '腽', '腭', '腧', '塍', '媵', '膈', '膂', '膑', '滕', '膣', '膪', '臌', '朦', '臊', '膻', '臁', '膦', '欤', '欷', '欹', '歃', '歆', '歙', '飑', '飒', '飓', '飕', '飙', '飚', '殳', '彀', '毂', '觳', '斐', '齑', '斓', '於', '旆', '旄', '旃', '旌', '旎', '旒', '旖', '炀', '炜', '炖', '炝', '炻', '烀', '炷', '炫', '炱', '烨', '烊', '焐', '焓', '焖', '焯', '焱', '煳', '煜', '煨', '煅', '煲', '煊', '煸', '煺', '熘', '熳', '熵', '熨', '熠', '燠', '燔', '燧', '燹', '爝', '爨', '灬', '焘', '煦', '熹', '戾', '戽', '扃', '扈', '扉', '礻', '祀', '祆', '祉', '祛', '祜', '祓', '祚', '祢', '祗', '祠', '祯', '祧', '祺', '禅', '禊', '禚', '禧', '禳', '忑', '忐', '怼', '恝', '恚', '恧', '恁', '恙', '恣', '悫', '愆', '愍', '慝', '憩', '憝', '懋', '懑', '戆', '肀', '聿', '沓', '泶', '淼', '矶', '矸', '砀', '砉', '砗', '砘', '砑', '斫', '砭', '砜', '砝', '砹', '砺', '砻', '砟', '砼', '砥', '砬', '砣', '砩', '硎', '硭', '硖', '硗', '砦', '硐', '硇', '硌', '硪', '碛', '碓', '碚', '碇', '碜', '碡', '碣', '碲', '碹', '碥', '磔', '磙', '磉', '磬', '磲', '礅', '磴', '礓', '礤', '礞', '礴', '龛', '黹', '黻', '黼', '盱', '眄', '眍', '盹', '眇', '眈', '眚', '眢', '眙', '眭', '眦', '眵', '眸', '睐', '睑', '睇', '睃', '睚', '睨', '睢', '睥', '睿', '瞍', '睽', '瞀', '瞌', '瞑', '瞟', '瞠', '瞰', '瞵', '瞽', '町', '畀', '畎', '畋', '畈', '畛', '畲', '畹', '疃', '罘', '罡', '罟', '詈', '罨', '罴', '罱', '罹', '羁', '罾', '盍', '盥', '蠲', '钅', '钆', '钇', '钋', '钊', '钌', '钍', '钏', '钐', '钔', '钗', '钕', '钚', '钛', '钜', '钣', '钤', '钫', '钪', '钭', '钬', '钯', '钰', '钲', '钴', '钶', '钷', '钸', '钹', '钺', '钼', '钽', '钿', '铄', '铈', '铉', '铊', '铋', '铌', '铍', '铎', '铐', '铑', '铒', '铕', '铖', '铗', '铙', '铘', '铛', '铞', '铟', '铠', '铢', '铤', '铥', '铧', '铨', '铪', '铩', '铫', '铮', '铯', '铳', '铴', '铵', '铷', '铹', '铼', '铽', '铿', '锃', '锂', '锆', '锇', '锉', '锊', '锍', '锎', '锏', '锒', '锓', '锔', '锕', '锖', '锘', '锛', '锝', '锞', '锟', '锢', '锪', '锫', '锩', '锬', '锱', '锲', '锴', '锶', '锷', '锸', '锼', '锾', '锿', '镂', '锵', '镄', '镅', '镆', '镉', '镌', '镎', '镏', '镒', '镓', '镔', '镖', '镗', '镘', '镙', '镛', '镞', '镟', '镝', '镡', '镢', '镤', '镥', '镦', '镧', '镨', '镩', '镪', '镫', '镬', '镯', '镱', '镲', '镳', '锺', '矧', '矬', '雉', '秕', '秭', '秣', '秫', '稆', '嵇', '稃', '稂', '稞', '稔', '稹', '稷', '穑', '黏', '馥', '穰', '皈', '皎', '皓', '皙', '皤', '瓞', '瓠', '甬', '鸠', '鸢', '鸨', '鸩', '鸪', '鸫', '鸬', '鸲', '鸱', '鸶', '鸸', '鸷', '鸹', '鸺', '鸾', '鹁', '鹂', '鹄', '鹆', '鹇', '鹈', '鹉', '鹋', '鹌', '鹎', '鹑', '鹕', '鹗', '鹚', '鹛', '鹜', '鹞', '鹣', '鹦', '鹧', '鹨', '鹩', '鹪', '鹫', '鹬', '鹱', '鹭', '鹳', '疒', '疔', '疖', '疠', '疝', '疬', '疣', '疳', '疴', '疸', '痄', '疱', '疰', '痃', '痂', '痖', '痍', '痣', '痨', '痦', '痤', '痫', '痧', '瘃', '痱', '痼', '痿', '瘐', '瘀', '瘅', '瘌', '瘗', '瘊', '瘥', '瘘', '瘕', '瘙', '瘛', '瘼', '瘢', '瘠', '癀', '瘭', '瘰', '瘿', '瘵', '癃', '瘾', '瘳', '癍', '癞', '癔', '癜', '癖', '癫', '癯', '翊', '竦', '穸', '穹', '窀', '窆', '窈', '窕', '窦', '窠', '窬', '窨', '窭', '窳', '衤', '衩', '衲', '衽', '衿', '袂', '袢', '裆', '袷', '袼', '裉', '裢', '裎', '裣', '裥', '裱', '褚', '裼', '裨', '裾', '裰', '褡', '褙', '褓', '褛', '褊', '褴', '褫', '褶', '襁', '襦', '襻', '疋', '胥', '皲', '皴', '矜', '耒', '耔', '耖', '耜', '耠', '耢', '耥', '耦', '耧', '耩', '耨', '耱', '耋', '耵', '聃', '聆', '聍', '聒', '聩', '聱', '覃', '顸', '颀', '颃', '颉', '颌', '颍', '颏', '颔', '颚', '颛', '颞', '颟', '颡', '颢', '颥', '颦', '虍', '虔', '虬', '虮', '虿', '虺', '虼', '虻', '蚨', '蚍', '蚋', '蚬', '蚝', '蚧', '蚣', '蚪', '蚓', '蚩', '蚶', '蛄', '蚵', '蛎', '蚰', '蚺', '蚱', '蚯', '蛉', '蛏', '蚴', '蛩', '蛱', '蛲', '蛭', '蛳', '蛐', '蜓', '蛞', '蛴', '蛟', '蛘', '蛑', '蜃', '蜇', '蛸', '蜈', '蜊', '蜍', '蜉', '蜣', '蜻', '蜞', '蜥', '蜮', '蜚', '蜾', '蝈', '蜴', '蜱', '蜩', '蜷', '蜿', '螂', '蜢', '蝽', '蝾', '蝻', '蝠', '蝰', '蝌', '蝮', '螋', '蝓', '蝣', '蝼', '蝤', '蝙', '蝥', '螓', '螯', '螨', '蟒', '蟆', '螈', '螅', '螭', '螗', '螃', '螫', '蟥', '螬', '螵', '螳', '蟋', '蟓', '螽', '蟑', '蟀', '蟊', '蟛', '蟪', '蟠', '蟮', '蠖', '蠓', '蟾', '蠊', '蠛', '蠡', '蠹', '蠼', '缶', '罂', '罄', '罅', '舐', '竺', '竽', '笈', '笃', '笄', '笕', '笊', '笫', '笏', '筇', '笸', '笪', '笙', '笮', '笱', '笠', '笥', '笤', '笳', '笾', '笞', '筘', '筚', '筅', '筵', '筌', '筝', '筠', '筮', '筻', '筢', '筲', '筱', '箐', '箦', '箧', '箸', '箬', '箝', '箨', '箅', '箪', '箜', '箢', '箫', '箴', '篑', '篁', '篌', '篝', '篚', '篥', '篦', '篪', '簌', '篾', '篼', '簏', '簖', '簋', '簟', '簪', '簦', '簸', '籁', '籀', '臾', '舁', '舂', '舄', '臬', '衄', '舡', '舢', '舣', '舭', '舯', '舨', '舫', '舸', '舻', '舳', '舴', '舾', '艄', '艉', '艋', '艏', '艚', '艟', '艨', '衾', '袅', '袈', '裘', '裟', '襞', '羝', '羟', '羧', '羯', '羰', '羲', '籼', '敉', '粑', '粝', '粜', '粞', '粢', '粲', '粼', '粽', '糁', '糇', '糌', '糍', '糈', '糅', '糗', '糨', '艮', '暨', '羿', '翎', '翕', '翥', '翡', '翦', '翩', '翮', '翳', '糸', '絷', '綦', '綮', '繇', '纛', '麸', '麴', '赳', '趄', '趔', '趑', '趱', '赧', '赭', '豇', '豉', '酊', '酐', '酎', '酏', '酤', '酢', '酡', '酰', '酩', '酯', '酽', '酾', '酲', '酴', '酹', '醌', '醅', '醐', '醍', '醑', '醢', '醣', '醪', '醭', '醮', '醯', '醵', '醴', '醺', '豕', '鹾', '趸', '跫', '踅', '蹙', '蹩', '趵', '趿', '趼', '趺', '跄', '跖', '跗', '跚', '跞', '跎', '跏', '跛', '跆', '跬', '跷', '跸', '跣', '跹', '跻', '跤', '踉', '跽', '踔', '踝', '踟', '踬', '踮', '踣', '踯', '踺', '蹀', '踹', '踵', '踽', '踱', '蹉', '蹁', '蹂', '蹑', '蹒', '蹊', '蹰', '蹶', '蹼', '蹯', '蹴', '躅', '躏', '躔', '躐', '躜', '躞', '豸', '貂', '貊', '貅', '貘', '貔', '斛', '觖', '觞', '觚', '觜', '觥', '觫', '觯', '訾', '謦', '靓', '雩', '雳', '雯', '霆', '霁', '霈', '霏', '霎', '霪', '霭', '霰', '霾', '龀', '龃', '龅', '龆', '龇', '龈', '龉', '龊', '龌', '黾', '鼋', '鼍', '隹', '隼', '隽', '雎', '雒', '瞿', '雠', '銎', '銮', '鋈', '錾', '鍪', '鏊', '鎏', '鐾', '鑫', '鱿', '鲂', '鲅', '鲆', '鲇', '鲈', '稣', '鲋', '鲎', '鲐', '鲑', '鲒', '鲔', '鲕', '鲚', '鲛', '鲞', '鲟', '鲠', '鲡', '鲢', '鲣', '鲥', '鲦', '鲧', '鲨', '鲩', '鲫', '鲭', '鲮', '鲰', '鲱', '鲲', '鲳', '鲴', '鲵', '鲶', '鲷', '鲺', '鲻', '鲼', '鲽', '鳄', '鳅', '鳆', '鳇', '鳊', '鳋', '鳌', '鳍', '鳎', '鳏', '鳐', '鳓', '鳔', '鳕', '鳗', '鳘', '鳙', '鳜', '鳝', '鳟', '鳢', '靼', '鞅', '鞑', '鞒', '鞔', '鞯', '鞫', '鞣', '鞲', '鞴', '骱', '骰', '骷', '鹘', '骶', '骺', '骼', '髁', '髀', '髅', '髂', '髋', '髌', '髑', '魅', '魃', '魇', '魉', '魈', '魍', '魑', '飨', '餍', '餮', '饕', '饔', '髟', '髡', '髦', '髯', '髫', '髻', '髭', '髹', '鬈', '鬏', '鬓', '鬟', '鬣', '麽', '麾', '縻', '麂', '麇', '麈', '麋', '麒', '鏖', '麝', '麟', '黛', '黜', '黝', '黠', '黟', '黢', '黩', '黧', '黥', '黪', '黯', '鼢', '鼬', '鼯', '鼹', '鼷', '鼽', '鼾', '齄']

VALID_CHARACTERS = chirp_common.CHARSET_ASCII + "".join(FONT_MAPPING)

def convert_bytes_to_chinese(data: bytes) -> str:
    """Convert bytes to a string of chinese characters"""
    last_byte = 0x00
    text = ''
    for byte in data:
        if last_byte == 0x00 and byte == 0xFF or byte == 0x00:
            break
        if byte >= 0x80 and last_byte == 0x00:
            last_byte = byte
            continue
        if last_byte != 0x00:
            text += bytes.fromhex(hex(last_byte).replace('0x', '') + hex(byte).replace('0x', '')).decode('gb2312')
            last_byte = 0x00
            continue
        text += chr(byte)
    return text


def convert_chinese_to_ascii_chars(data: str) -> str:
    text = ''
    for char in data:
        if char in chirp_common.CHARSET_ASCII:
            text += char
        elif char in FONT_MAPPING:
            reverse_str = char.encode("gb2312").hex()
            text += chr(int(reverse_str[:2], 16))
            text += chr(int(reverse_str[2:], 16))
    return text

class RadioSettingChineseValueString(RadioSettingValueString):

    """A string setting"""

    def __init__(self, minlength, maxlength, current,
                 autopad=True, charset=chirp_common.CHARSET_ASCII):
        RadioSettingValueString.__init__(self, minlength, maxlength, current, autopad, charset)

    def set_value(self, value):
        if len(value) < self._minlength or len(convert_chinese_to_ascii_chars(value)) > self._maxlength:
            raise InvalidValueError("Value must be between %i and %i chars" %
                                    (self._minlength, self._maxlength))
        if self._autopad:
            value = value.ljust(self._maxlength)
        for char in value:
            if char not in self._charset:
                raise InvalidValueError("Value contains invalid " +
                                        "character `%s'" % char)
        RadioSettingValue.set_value(self, value)


def get_mdc_contact_object(mem_obj, index):
    if index <= 16:
        return mem_obj.mdccontact1[index - 1]
    else:
        return mem_obj.mdccontact2[index - 17]


# the communication is obfuscated using this fine mechanism
def xorarr(data: bytes):
    tbl = [22, 108, 20, 230, 46, 145, 13, 64, 33, 53, 213, 64, 19, 3, 233, 128]
    x = b""
    r = 0
    for byte in data:
        x += bytes([byte ^ tbl[r]])
        r = (r+1) % len(tbl)
    return x


# if this crc was used for communication to AND from the radio, then it
# would be a measure to increase reliability.
# but it's only used towards the radio, so it's for further obfuscation
def calculate_crc16_xmodem(data: bytes):
    poly = 0x1021
    crc = 0x0
    for byte in data:
        crc = crc ^ (byte << 8)
        for i in range(8):
            crc = crc << 1
            if (crc & 0x10000):
                crc = (crc ^ poly) & 0xFFFF
    return crc & 0xFFFF


def _send_command(serport, data: bytes):
    """Send a command to UV-K5 radio"""
    LOG.debug("Sending command (unobfuscated) len=0x%4.4x:\n%s" %
              (len(data), util.hexprint(data)))

    crc = calculate_crc16_xmodem(data)
    data2 = data + struct.pack("<H", crc)

    command = struct.pack(">HBB", 0xabcd, len(data), 0) + \
        xorarr(data2) + \
        struct.pack(">H", 0xdcba)
    if DEBUG_SHOW_OBFUSCATED_COMMANDS:
        LOG.debug("Sending command (obfuscated):\n%s" % util.hexprint(command))
    try:
        result = serport.write(command)
    except Exception:
        raise errors.RadioError("Error writing data to radio")
    return result


def _receive_reply(serport):
    header = serport.read(4)
    if len(header) != 4:
        LOG.warning("Header short read: [%s] len=%i" %
                    (util.hexprint(header), len(header)))
        raise errors.RadioError("Header short read")
    if header[0] != 0xAB or header[1] != 0xCD or header[3] != 0x00:
        LOG.warning("Bad response header: %s len=%i" %
                    (util.hexprint(header), len(header)))
        raise errors.RadioError("Bad response header")

    cmd = serport.read(int(header[2]))
    if len(cmd) != int(header[2]):
        LOG.warning("Body short read: [%s] len=%i" %
                    (util.hexprint(cmd), len(cmd)))
        raise errors.RadioError("Command body short read")

    footer = serport.read(4)

    if len(footer) != 4:
        LOG.warning("Footer short read: [%s] len=%i" %
                    (util.hexprint(footer), len(footer)))
        raise errors.RadioError("Footer short read")

    if footer[2] != 0xDC or footer[3] != 0xBA:
        LOG.debug(
                "Reply before bad response footer (obfuscated)"
                "len=0x%4.4x:\n%s" % (len(cmd), util.hexprint(cmd)))
        LOG.warning("Bad response footer: %s len=%i" %
                    (util.hexprint(footer), len(footer)))
        raise errors.RadioError("Bad response footer")

    if DEBUG_SHOW_OBFUSCATED_COMMANDS:
        LOG.debug("Received reply (obfuscated) len=0x%4.4x:\n%s" %
                  (len(cmd), util.hexprint(cmd)))

    cmd2 = xorarr(cmd)

    LOG.debug("Received reply (unobfuscated) len=0x%4.4x:\n%s" %
              (len(cmd2), util.hexprint(cmd2)))

    return cmd2


def _getstring(data: bytes, begin, maxlen):
    tmplen = min(maxlen+1, len(data))
    s = [data[i] for i in range(begin, tmplen)]
    for key, val in enumerate(s):
        if val < ord(' ') or val > ord('~'):
            break
    return ''.join(chr(x) for x in s[0:key])


def _sayhello(serport):
    hellopacket = b"\x14\x05\x04\x00\x6a\x39\x57\x64"

    tries = 5
    while True:
        LOG.debug("Sending hello packet")
        _send_command(serport, hellopacket)
        o = _receive_reply(serport)
        if (o):
            break
        tries -= 1
        if tries == 0:
            LOG.warning("Failed to initialise radio")
            raise errors.RadioError("Failed to initialize radio")
    firmware = _getstring(o, 4, 16)
    LOG.info("Found firmware: %s" % firmware)
    return firmware


def _readmem(serport, offset, length):
    LOG.debug("Sending readmem offset=0x%4.4x len=0x%4.4x" % (offset, length))

    readmem = b"\x1b\x05\x08\x00" + \
        struct.pack("<HBB", offset, length, 0) + \
        b"\x6a\x39\x57\x64"
    _send_command(serport, readmem)
    o = _receive_reply(serport)
    if DEBUG_SHOW_MEMORY_ACTIONS:
        LOG.debug("readmem Received data len=0x%4.4x:\n%s" %
                  (len(o), util.hexprint(o)))
    return o[8:]


def _read_extra_mem(serport, offset: int, length: int, extra: int):
    extra_bytes = struct.pack("<H", extra)
    LOG.debug(
        "Sending read_extra_mem offset=0x%4.4x len=0x%4.4x extra=0x%4.4x" % (offset, length, extra))

    readmem = b"\x2b\x05\x08\x00" + \
              struct.pack("<HBB", offset, length, 0) + \
              b"\x6a\x39\x57\x64" + \
              extra_bytes
    _send_command(serport, readmem)
    o = _receive_reply(serport)
    if DEBUG_SHOW_MEMORY_ACTIONS:
        LOG.debug("read_extra_mem Received data len=0x%4.4x:\n%s" %
                  (len(o), util.hexprint(o)))
    return o[8:]


def _write_extra_mem(serport, offset: int, extra: int, data):
    extra_bytes = struct.pack("<H", extra)
    length = len(data) + len(extra_bytes)
    LOG.debug("Sending write_extra_mem offset=0x%4.4x len=0x%4.4x extra=0x%4.4x" %
              (offset, length, extra))

    if DEBUG_SHOW_MEMORY_ACTIONS:
        LOG.debug("write_extra_mem sent data offset=0x%4.4x len=0x%4.4x add=0x%4.4x:\n%s" %
                  (offset, length, extra, util.hexprint(data)))

    writemem = b"\x38\x05\x1c\x00" + \
        struct.pack("<HBB", offset, length, 0) + \
        b"\x6a\x39\x57\x64" + \
        extra_bytes + data

    _send_command(serport, writemem)
    o = _receive_reply(serport)

    LOG.debug("write_extra_mem Received data: %s len=%i" % (util.hexprint(o), len(o)))

    if (o[0] == 0x1e
            and
            o[4] == (offset & 0xff)
            and
            o[5] == (offset >> 8) & 0xff):
        return True
    else:
        LOG.warning("Bad data from write_extra_mem")
        raise errors.RadioError("Bad response to write_extra_mem")


def _writemem(serport, data, offset):
    LOG.debug("Sending writemem offset=0x%4.4x len=0x%4.4x" %
              (offset, len(data)))

    if DEBUG_SHOW_MEMORY_ACTIONS:
        LOG.debug("writemem sent data offset=0x%4.4x len=0x%4.4x:\n%s" %
                  (offset, len(data), util.hexprint(data)))

    dlen = len(data)
    writemem = b"\x1d\x05" + \
        struct.pack("<BBHBB", dlen+8, 0, offset, dlen, 1) + \
        b"\x6a\x39\x57\x64"+data

    _send_command(serport, writemem)
    o = _receive_reply(serport)

    LOG.debug("writemem Received data: %s len=%i" % (util.hexprint(o), len(o)))

    if (o[0] == 0x1e
            and
            o[4] == (offset & 0xff)
            and
            o[5] == (offset >> 8) & 0xff):
        return True
    else:
        LOG.warning("Bad data from writemem")
        raise errors.RadioError("Bad response to writemem")


def _resetradio(serport):
    resetpacket = b"\xdd\x05\x00\x00"
    _send_command(serport, resetpacket)


def do_download(radio):
    serport = radio.pipe
    serport.timeout = 0.5
    status = chirp_common.Status()
    status.cur = 0
    status.max = MEM_SIZE
    status.msg = "正在从电台下载数据"
    radio.status_fn(status)

    eeprom = b""
    f = _sayhello(serport)
    if f:
        radio.FIRMWARE_VERSION = f
    else:
        raise errors.RadioError('无法检测固件版本')

    addr = 0
    while addr < MEM_SIZE:
        o = _readmem(serport, addr, MEM_BLOCK)
        status.cur = addr
        radio.status_fn(status)

        if o and len(o) == MEM_BLOCK:
            eeprom += o
            addr += MEM_BLOCK
        else:
            raise errors.RadioError("信道未完全下载")
    status.cur = addr
    radio.status_fn(status)
    return memmap.MemoryMapBytes(eeprom)


def do_extra_download(radio):
    if not radio.FIRMWARE_VERSION.endswith('K'):
        return [b'', b'']
    serport = radio.pipe
    serport.timeout = 0.5
    status = chirp_common.Status()
    status.cur = 0
    status.max = 3
    status.msg = "正在从电台下载扩容部分数据"
    radio.status_fn(status)

    f = _sayhello(serport)
    if f:
        radio.FIRMWARE_VERSION = f
    else:
        raise errors.RadioError('无法检测固件版本')

    welcome_len = _read_extra_mem(serport, 0x01, 0x02, 0xE31E)
    status.cur = 1
    radio.status_fn(status)
    welcome_len1, welcome_len2 = welcome_len
    if welcome_len1 > 18:
        welcome_len1 = 18
    if welcome_len2 > 18:
        welcome_len2 = 18
    welcome_text_1 = _read_extra_mem(serport, 0x01, welcome_len1, 0xE320)
    status.cur = 2
    radio.status_fn(status)
    welcome_text_2 = _read_extra_mem(serport, 0x01, welcome_len2, 0xE333)
    status.cur = 3
    radio.status_fn(status)
    return [welcome_text_1, welcome_text_2]


def do_upload(radio):
    serport = radio.pipe
    serport.timeout = 0.5
    status = chirp_common.Status()
    status.cur = 0
    status.max = PROG_SIZE + 0x70
    status.msg = "正在向电台上传数据"
    radio.status_fn(status)

    f = _sayhello(serport)
    if f:
        radio.FIRMWARE_VERSION = f
    else:
        return False

    addr = 0
    while addr < PROG_SIZE:
        o = radio.get_mmap()[addr:addr+MEM_BLOCK]
        _writemem(serport, o, addr)
        status.cur = addr
        radio.status_fn(status)
        if o:
            addr += MEM_BLOCK
        else:
            raise errors.RadioError("信道未完全上传")
    status.cur = addr
    radio.status_fn(status)

    o = radio.get_mmap()[0x1F90:0x2000]
    _writemem(serport, o, 0x1F90)
    status.cur = PROG_SIZE + 0x70
    radio.status_fn(status)

    status.msg = "上传数据完成"

    return True


def do_extra_upload(radio):
    serport = radio.pipe
    serport.timeout = 0.5
    status = chirp_common.Status()
    status.cur = 0
    status.max = 3
    status.msg = "正在向电台上传扩容部分数据"
    radio.status_fn(status)

    f = _sayhello(serport)
    if f:
        radio.FIRMWARE_VERSION = f
    else:
        return False

    if radio.FIRMWARE_VERSION.endswith('K'):
        welcome_logo = radio.get_welcome_logo()
        _write_extra_mem(serport, 0x01, 0xE31E, bytes([len(x) for x in welcome_logo]))
        status.cur += 1
        radio.status_fn(status)
        _write_extra_mem(serport, 0x01, 0xE320, b'\x00' * 18)
        _write_extra_mem(serport, 0x01, 0xE320, welcome_logo[0])
        status.cur += 1
        radio.status_fn(status)
        _write_extra_mem(serport, 0x01, 0xE333, b'\x00' * 18)
        _write_extra_mem(serport, 0x01, 0xE333, welcome_logo[1])
        status.cur += 1
        radio.status_fn(status)
    else:
        status.cur += 3
        radio.status_fn(status)
    status.msg = "扩容部分数据上传完成"

    return True


def _find_band(nolimits, hz):
    mhz = hz/1000000.0
    if nolimits:
        B = BANDS_NOLIMITS
    else:
        B = BANDS

    # currently the hacked firmware sets band=1 below 50 MHz
    if nolimits and mhz < 50.0:
        return 1

    for a in B:
        if mhz >= B[a][0] and mhz <= B[a][1]:
            return a
    return False


@directory.register
class UVK5Radio(chirp_common.CloneModeRadio):
    """Quansheng UV-K5"""
    VENDOR = "Quansheng"
    MODEL = "UV-K5 (cn)"
    BAUD_RATE = 38400
    NEEDS_COMPAT_SERIAL = False
    FIRMWARE_VERSION = ""
    _expanded_limits = False

    def __init__(self, pipe):
          super().__init__(pipe)
          self._welcome_logo = [b'', b'']

    def get_prompts(x=None):
        rp = chirp_common.RadioPrompts()
        rp.experimental = (
            '这是用于 Quansheng UV-K5 的实验性驱动。它可能会损坏您的电台，甚至更糟。请自行承担风险。\n'
            '\n' 
            '在尝试进行任何更改之前，请使用 CHIRP 从电台中下载信道镜像并保存下来。这稍后可以用于恢复原始设置。\n'
            '\n'
            '一些细节尚未实现')
        rp.pre_download = (
            "1. 打开电台。\n"
            "2. 将写频线连接到麦克风/扬声器接口。\n"
            "3. 确保连接牢固。\n"
            "4. 点击确定 从设备下载镜像。\n"
            "\n"
            "如果在写频线已经连接的情况下打开电台，可能无法正常使用\n"
        )
        rp.pre_upload = (
            "1. 打开电台。\n"
            "2. 将写频线连接到麦克风/扬声器接口。\n"
            "3. 确保连接牢固。\n"
            "4. 点击确定 将镜像上传到设备。\n"
            "\n"
            "如果在写频线已经连接的情况下打开电台，可能无法正常使用\n"
        )
        return rp

    # Return information about this radio's features, including
    # how many memories it has, what bands it supports, etc
    def get_features(self):
        rf = chirp_common.RadioFeatures()
        rf.has_bank = False
        rf.valid_dtcs_codes = DTCS_CODES
        rf.has_rx_dtcs = True
        rf.has_ctone = True
        rf.has_settings = True
        rf.has_comment = False
        rf.valid_name_length = 10
        rf.valid_power_levels = UVK5_POWER_LEVELS
        rf.valid_special_chans = list(SPECIALS.keys())
        rf.valid_duplexes = ["", "-", "+", "off"]

        # hack so we can input any frequency,
        # the 0.1 and 0.01 steps don't work unfortunately
        rf.valid_tuning_steps = [0.01, 0.1, 1.0] + STEPS

        rf.valid_tmodes = ["", "Tone", "TSQL", "DTCS", "Cross"]
        rf.valid_cross_modes = ["Tone->Tone", "Tone->DTCS", "DTCS->Tone",
                                "->Tone", "->DTCS", "DTCS->", "DTCS->DTCS"]

        rf.valid_characters = VALID_CHARACTERS
        rf.valid_modes = ["FM", "NFM", "AM", "NAM"]

        rf.valid_skips = [""]

        # This radio supports memories 1-200, 201-214 are the VFO memories
        rf.memory_bounds = (1, 200)

        rf.valid_bands = []
        for a in BANDS_NOLIMITS:
            rf.valid_bands.append(
                    (int(BANDS_NOLIMITS[a][0]*1000000),
                     int(BANDS_NOLIMITS[a][1]*1000000)))
        return rf

    # Do a download of the radio from the serial port
    def sync_in(self):
        self._mmap = do_download(self)
        self._welcome_logo = do_extra_download(self)
        self.process_mmap()

    # Do an upload of the radio to the serial port
    def sync_out(self):
        do_upload(self)
        do_extra_upload(self)
        _resetradio(self.pipe)

    # Convert the raw byte array into a memory object structure
    def process_mmap(self):
        self._memobj = bitwise.parse(MEM_FORMAT, self._mmap)

    # Return a raw representation of the memory object, which
    # is very helpful for development
    def get_raw_memory(self, number):
        return repr(self._memobj.channel[number-1])

    def get_welcome_logo(self):
        return self._welcome_logo

    def validate_memory(self, mem):
        msgs = super().validate_memory(mem)

        if mem.duplex == 'off':
            return msgs

        # find tx frequency
        if mem.duplex == '-':
            txfreq = mem.freq - mem.offset
        elif mem.duplex == '+':
            txfreq = mem.freq + mem.offset
        else:
            txfreq = mem.freq

        # find band
        band = _find_band(self._expanded_limits, txfreq)
        if band is False:
            msg = "Transmit frequency %.4f MHz is not supported by this radio"\
                   % (txfreq/1000000.0)
            msgs.append(chirp_common.ValidationError(msg))

        band = _find_band(self._expanded_limits, mem.freq)
        if band is False:
            msg = "The frequency %.4f MHz is not supported by this radio" \
                   % (mem.freq/1000000.0)
            msgs.append(chirp_common.ValidationError(msg))

        return msgs

    def _set_tone(self, mem, _mem):
        ((txmode, txtone, txpol),
         (rxmode, rxtone, rxpol)) = chirp_common.split_tone_encode(mem)

        if txmode == "Tone":
            txtoval = CTCSS_TONES.index(txtone)
            txmoval = 0b01
        elif txmode == "DTCS":
            txmoval = txpol == "R" and 0b11 or 0b10
            txtoval = DTCS_CODES.index(txtone)
        else:
            txmoval = 0
            txtoval = 0

        if rxmode == "Tone":
            rxtoval = CTCSS_TONES.index(rxtone)
            rxmoval = 0b01
        elif rxmode == "DTCS":
            rxmoval = rxpol == "R" and 0b11 or 0b10
            rxtoval = DTCS_CODES.index(rxtone)
        else:
            rxmoval = 0
            rxtoval = 0

        _mem.rxcodeflag = rxmoval
        _mem.txcodeflag = txmoval
        _mem.unknown1 = 0
        _mem.unknown2 = 0
        _mem.rxcode = rxtoval
        _mem.txcode = txtoval

    def _get_tone(self, mem, _mem):
        rxtype = _mem.rxcodeflag
        txtype = _mem.txcodeflag
        rx_tmode = TMODES[rxtype]
        tx_tmode = TMODES[txtype]

        rx_tone = tx_tone = None

        if tx_tmode == "Tone":
            if _mem.txcode < len(CTCSS_TONES):
                tx_tone = CTCSS_TONES[_mem.txcode]
            else:
                tx_tone = 0
                tx_tmode = ""
        elif tx_tmode == "DTCS":
            if _mem.txcode < len(DTCS_CODES):
                tx_tone = DTCS_CODES[_mem.txcode]
            else:
                tx_tone = 0
                tx_tmode = ""

        if rx_tmode == "Tone":
            if _mem.rxcode < len(CTCSS_TONES):
                rx_tone = CTCSS_TONES[_mem.rxcode]
            else:
                rx_tone = 0
                rx_tmode = ""
        elif rx_tmode == "DTCS":
            if _mem.rxcode < len(DTCS_CODES):
                rx_tone = DTCS_CODES[_mem.rxcode]
            else:
                rx_tone = 0
                rx_tmode = ""

        tx_pol = txtype == 0x03 and "R" or "N"
        rx_pol = rxtype == 0x03 and "R" or "N"

        chirp_common.split_tone_decode(mem, (tx_tmode, tx_tone, tx_pol),
                                       (rx_tmode, rx_tone, rx_pol))

    # Extract a high-level memory object from the low-level memory map
    # This is called to populate a memory in the UI
    def get_memory(self, number2):

        mem = chirp_common.Memory()

        if isinstance(number2, str):
            number = SPECIALS[number2]
            mem.extd_number = number2
        else:
            number = number2 - 1

        mem.number = number + 1

        _mem = self._memobj.channel[number]

        tmpcomment = ""

        is_empty = False
        # We'll consider any blank (i.e. 0 MHz frequency) to be empty
        if (_mem.freq == 0xffffffff) or (_mem.freq == 0):
            is_empty = True

        tmpscn = SCANLIST_LIST[0]

        # We'll also look at the channel attributes if a memory has them
        if number < 200:
            _mem3 = self._memobj.channel_attributes[number]
            # free memory bit
            if _mem3.is_free > 0:
                is_empty = True
            # scanlists
            if _mem3.is_scanlist1 > 0 and _mem3.is_scanlist2 > 0:
                tmpscn = SCANLIST_LIST[3]  # "1+2"
            elif _mem3.is_scanlist1 > 0:
                tmpscn = SCANLIST_LIST[1]  # "1"
            elif _mem3.is_scanlist2 > 0:
                tmpscn = SCANLIST_LIST[2]  # "2"

        if is_empty:
            mem.empty = True
            # set some sane defaults:
            mem.power = UVK5_POWER_LEVELS[2]
            mem.extra = RadioSettingGroup("Extra", "extra")
            rs = RadioSetting(
                "bclo", "遇忙禁发",
                RadioSettingValueBoolean(False))
            mem.extra.append(rs)
            rs = RadioSetting(
                "frev", "倒频",
                RadioSettingValueBoolean(False))
            mem.extra.append(rs)
            rs = RadioSetting(
                "pttid", "PTTID",
                RadioSettingValueList(PTTID_LIST, PTTID_LIST[0]))
            mem.extra.append(rs)
            rs = RadioSetting(
                "dtmfdecode", "DTMF解码",
                RadioSettingValueBoolean(False))
            mem.extra.append(rs)
            rs = RadioSetting(
                "scrambler", "扰频",
                RadioSettingValueList(SCRAMBLER_LIST, SCRAMBLER_LIST[0]))
            mem.extra.append(rs)

            rs = RadioSetting(
                "scanlists", "扫描列表",
                RadioSettingValueList(SCANLIST_LIST, SCANLIST_LIST[0]))
            mem.extra.append(rs)

            # actually the step and duplex are overwritten by chirp based on
            # bandplan. they are here to document sane defaults for IARU r1
            # mem.tuning_step = 25.0
            # mem.duplex = ""

            return mem

        if number > 199:
            mem.immutable = ["name", "scanlists"]
        else:
            _mem2 = self._memobj.channelname[number]
            raw_bytes = _mem2.get_raw()
            mem.name = convert_bytes_to_chinese(raw_bytes).rstrip()

        # Convert your low-level frequency to Hertz
        mem.freq = int(_mem.freq)*10
        mem.offset = int(_mem.offset)*10

        if (mem.offset == 0):
            mem.duplex = ''
        else:
            if _mem.shift == FLAGS1_OFFSET_MINUS:
                if _mem.freq == _mem.offset:
                    # fake tx disable by setting tx to 0 MHz
                    mem.duplex = 'off'
                    mem.offset = 0
                else:
                    mem.duplex = '-'
            elif _mem.shift == FLAGS1_OFFSET_PLUS:
                mem.duplex = '+'
            else:
                mem.duplex = ''

        # tone data
        self._get_tone(mem, _mem)

        # mode
        if _mem.enable_am > 0:
            if _mem.bandwidth > 0:
                mem.mode = "NAM"
            else:
                mem.mode = "AM"
        else:
            if _mem.bandwidth > 0:
                mem.mode = "NFM"
            else:
                mem.mode = "FM"

        # tuning step
        tstep = _mem.step & 0x7
        if tstep < len(STEPS):
            mem.tuning_step = STEPS[tstep]
        else:
            mem.tuning_step = 2.5

        # power
        if _mem.txpower == POWER_HIGH:
            mem.power = UVK5_POWER_LEVELS[2]
        elif _mem.txpower == POWER_MEDIUM:
            mem.power = UVK5_POWER_LEVELS[1]
        else:
            mem.power = UVK5_POWER_LEVELS[0]

        # We'll consider any blank (i.e. 0 MHz frequency) to be empty
        if (_mem.freq == 0xffffffff) or (_mem.freq == 0):
            mem.empty = True
        else:
            mem.empty = False

        mem.extra = RadioSettingGroup("Extra", "extra")

        # BCLO
        is_bclo = bool(_mem.bclo > 0)
        rs = RadioSetting("bclo", "遇忙禁发", RadioSettingValueBoolean(is_bclo))
        mem.extra.append(rs)
        tmpcomment += "BCLO:"+(is_bclo and "ON" or "off")+" "

        # Frequency reverse - whatever that means, don't see it in the manual
        is_frev = bool(_mem.freq_reverse > 0)
        rs = RadioSetting("frev", "倒频", RadioSettingValueBoolean(is_frev))
        mem.extra.append(rs)
        tmpcomment += "FreqReverse:"+(is_frev and "ON" or "off")+" "

        # PTTID
        pttid = _mem.dtmf_pttid
        rs = RadioSetting("pttid", "PTTID", RadioSettingValueList(
            PTTID_LIST, PTTID_LIST[pttid]))
        mem.extra.append(rs)
        tmpcomment += "PTTid:"+PTTID_LIST[pttid]+" "

        # DTMF DECODE
        is_dtmf = bool(_mem.dtmf_decode > 0)
        rs = RadioSetting("dtmfdecode", "DTMF解码",
                          RadioSettingValueBoolean(is_dtmf))
        mem.extra.append(rs)
        tmpcomment += "DTMFdecode:"+(is_dtmf and "ON" or "off")+" "

        # Scrambler
        if _mem.scrambler & 0x0f < len(SCRAMBLER_LIST):
            enc = _mem.scrambler & 0x0f
        else:
            enc = 0

        rs = RadioSetting("scrambler", "扰频", RadioSettingValueList(
            SCRAMBLER_LIST, SCRAMBLER_LIST[enc]))
        mem.extra.append(rs)
        tmpcomment += "Scrambler:"+SCRAMBLER_LIST[enc]+" "

        rs = RadioSetting("scanlists", "扫描列表", RadioSettingValueList(
            SCANLIST_LIST, tmpscn))
        mem.extra.append(rs)

        return mem

    def set_settings(self, settings):
        _mem = self._memobj
        for element in settings:
            if not isinstance(element, RadioSetting):
                self.set_settings(element)
                continue

            # basic settings

            # call channel
            if element.get_name() == "call_channel":
                _mem.call_channel = int(element.value)-1

            # squelch
            if element.get_name() == "squelch":
                _mem.squelch = int(element.value)
            # TOT
            if element.get_name() == "tot":
                _mem.max_talk_time = int(element.value)

            # NOAA autoscan
            if element.get_name() == "noaa_autoscan":
                _mem.noaa_autoscan = element.value and 1 or 0

            # VOX switch
            if element.get_name() == "vox_switch":
                _mem.vox_switch = element.value and 1 or 0

            # vox level
            if element.get_name() == "vox_level":
                _mem.vox_level = int(element.value)-1

            # mic gain
            if element.get_name() == "mic_gain":
                if str(element.value) in MIC_GAIN_LIST:
                    _mem.mic_gain = int(MIC_GAIN_LIST.index(str(element.value)))
                else:
                    _mem.mic_gain = 2

            # Channel display mode
            if element.get_name() == "channel_display_mode":
                _mem.channel_display_mode = CHANNELDISP_LIST.index(
                    str(element.value))

            # Crossband receiving/transmitting
            if element.get_name() == "crossband":
                _mem.crossband = CROSSBAND_LIST.index(str(element.value))

            # Battery Save
            if element.get_name() == "battery_save":
                _mem.battery_save = BATSAVE_LIST.index(str(element.value))
            # Dual Watch
            if element.get_name() == "dualwatch":
                _mem.dual_watch = DUALWATCH_LIST.index(str(element.value))

            # Backlight auto mode
            if element.get_name() == "backlight_auto_mode":
                _mem.backlight_auto_mode = \
                        BACKLIGHT_LIST.index(str(element.value))

            # Tail tone elimination
            if element.get_name() == "tail_note_elimination":
                _mem.tail_note_elimination = element.value and 1 or 0

            # VFO Open
            if element.get_name() == "vfo_open":
                _mem.vfo_open = element.value and 1 or 0

            # Beep control
            if element.get_name() == "beep_control":
                _mem.beep_control = element.value and 1 or 0

            # Scan resume mode
            if element.get_name() == "scan_resume_mode":
                _mem.scan_resume_mode = SCANRESUME_LIST.index(
                    str(element.value))

            # Keypad lock
            if element.get_name() == "key_lock":
                _mem.key_lock = element.value and 1 or 0

            # Auto keypad lock
            if element.get_name() == "auto_keypad_lock":
                _mem.auto_keypad_lock = element.value and 1 or 0

            # Power on display mode
            if element.get_name() == "welcome_mode":
                _mem.power_on_dispmode = WELCOME_LIST.index(str(element.value))

            # Keypad Tone
            if element.get_name() == "keypad_tone":
                _mem.keypad_tone = KEYPADTONE_LIST.index(str(element.value))

            # Language
            if element.get_name() == "language":
                _mem.language = LANGUAGE_LIST.index(str(element.value))

            # Alarm mode
            if element.get_name() == "alarm_mode":
                _mem.alarm_mode = ALARMMODE_LIST.index(str(element.value))

            # Reminding of end of talk
            if element.get_name() == "reminding_of_end_talk":
                _mem.reminding_of_end_talk = REMENDOFTALK_LIST.index(
                    str(element.value))

            # Repeater tail tone elimination
            if element.get_name() == "repeater_tail_elimination":
                _mem.repeater_tail_elimination = RTE_LIST.index(
                    str(element.value))

            # Logo string 1
            if element.get_name() == "logo1":
                if self.FIRMWARE_VERSION.endswith('K'):
                    b = convert_chinese_to_ascii_chars(element.value).encode('latin-1')
                    self._welcome_logo[0] = b[0:18]
                else:
                    b = str(element.value).rstrip("\x20\xff\x00") + "\x00" * 12
                    _mem.logo_line1 = b[0:12] + "\x00\xff\xff\xff"

            # Logo string 2
            if element.get_name() == "logo2":
                if self.FIRMWARE_VERSION.endswith('K'):
                    b = convert_chinese_to_ascii_chars(element.value).encode('latin-1')
                    self._welcome_logo[1] = b[0:18]
                else:
                    b = str(element.value).rstrip("\x20\xff\x00") + "\x00" * 12
                    _mem.logo_line2 = b[0:12] + "\x00\xff\xff\xff"

            # unlock settings

            # FLOCK
            if element.get_name() == "flock":
                _mem.lock_flock = FLOCK_LIST.index(str(element.value))

            # # 350TX
            # if element.get_name() == "tx350":
            #     _mem.lock.tx350 = element.value and 1 or 0
            #
            # # 200TX
            # if element.get_name() == "tx200":
            #     _mem.lock.tx200 = element.value and 1 or 0
            #
            # # 500TX
            # if element.get_name() == "tx500":
            #     _mem.lock.tx500 = element.value and 1 or 0
            #
            # # 350EN
            # if element.get_name() == "en350":
            #     _mem.lock.en350 = element.value and 1 or 0

            # SCREN
            if element.get_name() == "enscramble":
                _mem.lock_enscramble = element.value and 1 or 0

            # KILLED
            if element.get_name() == "killed":
                _mem.lock_killed = element.value and 1 or 0

            # fm radio
            for i in range(1, 21):
                freqname = "FM_" + str(i)
                if element.get_name() == freqname:
                    val = str(element.value).strip()
                    try:
                        val2 = int(float(val)*10)
                    except Exception:
                        val2 = 0xffff

                    if val2 < FMMIN*10 or val2 > FMMAX*10:
                        val2 = 0xffff
#                        raise errors.InvalidValueError(
#                                "FM radio frequency should be a value "
#                                "in the range %.1f - %.1f" % (FMMIN , FMMAX))
                    _mem.fmfreq[i-1] = val2

            # dtmf settings
            if element.get_name() == "dtmf_side_tone":
                _mem.dtmf_settings.side_tone = \
                        element.value and 1 or 0

            if element.get_name() == "dtmf_separate_code":
                _mem.dtmf_settings.separate_code = str(element.value)

            if element.get_name() == "dtmf_group_call_code":
                _mem.dtmf_settings.group_call_code = element.value

            if element.get_name() == "dtmf_decode_response":
                _mem.dtmf_settings.decode_response = \
                        DTMF_DECODE_RESPONSE_LIST.index(str(element.value))

            if element.get_name() == "dtmf_auto_reset_time":
                _mem.dtmf_settings.auto_reset_time = \
                        int(int(element.value)/10)

            if element.get_name() == "dtmf_preload_time":
                _mem.dtmf_settings.preload_time = \
                        int(int(element.value)/10)

            if element.get_name() == "dtmf_first_code_persist_time":
                _mem.dtmf_settings.first_code_persist_time = \
                        int(int(element.value)/10)

            if element.get_name() == "dtmf_hash_persist_time":
                _mem.dtmf_settings.hash_persist_time = \
                        int(int(element.value)/10)

            if element.get_name() == "dtmf_code_persist_time":
                _mem.dtmf_settings.code_persist_time = \
                        int(int(element.value)/10)

            if element.get_name() == "dtmf_code_interval_time":
                _mem.dtmf_settings.code_interval_time = \
                        int(int(element.value)/10)

            if element.get_name() == "dtmf_permit_remote_kill":
                _mem.dtmf_settings.permit_remote_kill = \
                        element.value and 1 or 0

            if element.get_name() == "dtmf_dtmf_local_code":
                k = str(element.value).rstrip("\x20\xff\x00") + "\x00"*3
                _mem.dtmf_settings_numbers.dtmf_local_code = k[0:3]

            if element.get_name() == "dtmf_dtmf_up_code":
                k = str(element.value).strip("\x20\xff\x00") + "\x00"*16
                _mem.dtmf_settings_numbers.dtmf_up_code = k[0:16]

            if element.get_name() == "dtmf_dtmf_down_code":
                k = str(element.value).rstrip("\x20\xff\x00") + "\x00"*16
                _mem.dtmf_settings_numbers.dtmf_down_code = k[0:16]

            if element.get_name() == "dtmf_kill_code":
                k = str(element.value).strip("\x20\xff\x00") + "\x00"*5
                _mem.dtmf_settings_numbers.kill_code = k[0:5]

            if element.get_name() == "dtmf_revive_code":
                k = str(element.value).strip("\x20\xff\x00") + "\x00"*5
                _mem.dtmf_settings_numbers.revive_code = k[0:5]

            # dtmf contacts
            for i in range(1, 17):
                varname = "DTMF_" + str(i)
                if element.get_name() == varname:
                    k = str(element.value).rstrip("\x20\xff\x00") + "\x00"*8
                    _mem.dtmfcontact[i-1].name = k[0:8]

                varnumname = "DTMFNUM_" + str(i)
                if element.get_name() == varnumname:
                    k = str(element.value).rstrip("\x20\xff\x00") + "\xff"*3
                    _mem.dtmfcontact[i-1].number = k[0:3]

            # MDC 联系人
            element_name = element.get_name()
            valid_mdc = 0
            last_valid = 0
            for i in range(1, 23):
                mdc_id = "MDC_ID_" + str(i)
                mdc_name = "MDC_NAME_" + str(i)
                if element_name == mdc_id:
                    k = str(element.value).replace(' ', '').rjust(4, '0')
                    get_mdc_contact_object(_mem, i).id = bytes.fromhex(k)[0:2]

                if element_name == mdc_name:
                    get_mdc_contact_object(_mem, i).name = str(element.value)[0:14]

                mdc_obj = get_mdc_contact_object(_mem, i)
                is_not_empty = mdc_obj.id.get_raw() != b'\x00' * 2 and mdc_obj.name.get_raw() != b'\x20' * 20
                if is_not_empty and (last_valid == i - 1 or last_valid == 0):
                    valid_mdc = i
                    last_valid = i
            _mem.mdc_num = valid_mdc

            # scanlist stuff
            if element.get_name() == "scanlist_default":
                val = (int(element.value) == 2) and 1 or 0
                _mem.scanlist_default = val

            if element.get_name() == "scanlist1_priority_scan":
                _mem.scanlist1_priority_scan = \
                        element.value and 1 or 0

            if element.get_name() == "scanlist2_priority_scan":
                _mem.scanlist2_priority_scan = \
                        element.value and 1 or 0

            if element.get_name() == "scanlist1_priority_ch1" or \
                    element.get_name() == "scanlist1_priority_ch2" or \
                    element.get_name() == "scanlist2_priority_ch1" or \
                    element.get_name() == "scanlist2_priority_ch2":

                val = int(element.value)

                if val > 200 or val < 1:
                    val = 0xff
                else:
                    val -= 1

                if element.get_name() == "scanlist1_priority_ch1":
                    _mem.scanlist1_priority_ch1 = val
                if element.get_name() == "scanlist1_priority_ch2":
                    _mem.scanlist1_priority_ch2 = val
                if element.get_name() == "scanlist2_priority_ch1":
                    _mem.scanlist2_priority_ch1 = val
                if element.get_name() == "scanlist2_priority_ch2":
                    _mem.scanlist2_priority_ch2 = val

            if element.get_name() == "key1_shortpress_action":
                _mem.key1_shortpress_action = KEYACTIONS_SHORT_LIST.index(
                        str(element.value))

            if element.get_name() == "key1_longpress_action":
                _mem.key1_longpress_action = KEYACTIONS_LONG_LIST.index(
                        str(element.value))

            if element.get_name() == "key2_shortpress_action":
                _mem.key2_shortpress_action = KEYACTIONS_SHORT_LIST.index(
                        str(element.value))

            if element.get_name() == "key2_longpress_action":
                _mem.key2_longpress_action = KEYACTIONS_LONG_LIST.index(
                        str(element.value))

            if element.get_name() == "mkey_longpress_action":
                _mem.key2_longpress_action = KEYACTIONS_LONG_LIST.index(
                        str(element.value))

            if element.get_name() == "nolimits":
                LOG.warning("User expanded band limits")
                self._expanded_limits = bool(element.value)

    def get_settings(self):
        _mem = self._memobj
        basic = RadioSettingGroup("basic", "基本设置")
        keya = RadioSettingGroup("keya", "自定义按键")
        dtmf = RadioSettingGroup("dtmf", "DTMF 设置")
        dtmfc = RadioSettingGroup("dtmfc", "DTMF 联系人")
        mdcc = RadioSettingGroup("mdcc", "MDC 联系人")
        scanl = RadioSettingGroup("scn", "扫描列表")
        unlock = RadioSettingGroup("unlock", "解锁设置")
        fmradio = RadioSettingGroup("fmradio", "FM广播")

        roinfo = RadioSettingGroup("roinfo", "设备信息")

        top = RadioSettings(
                basic, keya, dtmf, dtmfc, mdcc, scanl, unlock, fmradio, roinfo)

        # Programmable keys
        tmpval = int(_mem.key1_shortpress_action)
        if tmpval >= len(KEYACTIONS_SHORT_LIST):
            tmpval = 0
        rs = RadioSetting("key1_shortpress_action", "侧键1短按",
                          RadioSettingValueList(
                              KEYACTIONS_SHORT_LIST, KEYACTIONS_SHORT_LIST[tmpval]))
        keya.append(rs)

        tmpval = int(_mem.key1_longpress_action)
        if tmpval >= len(KEYACTIONS_LONG_LIST):
            tmpval = 0
        rs = RadioSetting("key1_longpress_action", "侧键1长按",
                          RadioSettingValueList(
                              KEYACTIONS_LONG_LIST, KEYACTIONS_LONG_LIST[tmpval]))
        keya.append(rs)

        tmpval = int(_mem.key2_shortpress_action)
        if tmpval >= len(KEYACTIONS_SHORT_LIST):
            tmpval = 0
        rs = RadioSetting("key2_shortpress_action", "侧键2短按",
                          RadioSettingValueList(
                              KEYACTIONS_SHORT_LIST, KEYACTIONS_SHORT_LIST[tmpval]))
        keya.append(rs)

        tmpval = int(_mem.key2_longpress_action)
        if tmpval >= len(KEYACTIONS_LONG_LIST):
            tmpval = 0
        rs = RadioSetting("key2_longpress_action", "侧键2长按",
                          RadioSettingValueList(
                              KEYACTIONS_LONG_LIST, KEYACTIONS_LONG_LIST[tmpval]))
        keya.append(rs)

        tmpval = int(_mem.mkey_longpress_action)
        if tmpval >= len(KEYACTIONS_LONG_LIST):
            tmpval = 0
        rs = RadioSetting("mkey_longpress_action", "M键长按",
                          RadioSettingValueList(
                              KEYACTIONS_LONG_LIST, KEYACTIONS_LONG_LIST[tmpval]))
        keya.append(rs)

        # DTMF settings
        tmppr = bool(_mem.dtmf_settings.side_tone > 0)
        rs = RadioSetting(
                "dtmf_side_tone",
                "DTMF 侧音",
                RadioSettingValueBoolean(tmppr))
        dtmf.append(rs)

        tmpval = str(_mem.dtmf_settings.separate_code)
        if tmpval not in DTMF_CODE_CHARS:
            tmpval = '*'
        val = RadioSettingValueString(1, 1, tmpval)
        val.set_charset(DTMF_CODE_CHARS)
        rs = RadioSetting("dtmf_separate_code", "分隔码", val)
        dtmf.append(rs)

        tmpval = str(_mem.dtmf_settings.group_call_code)
        if tmpval not in DTMF_CODE_CHARS:
            tmpval = '#'
        val = RadioSettingValueString(1, 1, tmpval)
        val.set_charset(DTMF_CODE_CHARS)
        rs = RadioSetting("dtmf_group_call_code", "组呼码", val)
        dtmf.append(rs)

        tmpval = _mem.dtmf_settings.decode_response
        if tmpval >= len(DTMF_DECODE_RESPONSE_LIST):
            tmpval = 0
        rs = RadioSetting("dtmf_decode_response", "解码响应",
                          RadioSettingValueList(
                              DTMF_DECODE_RESPONSE_LIST,
                              DTMF_DECODE_RESPONSE_LIST[tmpval]))
        dtmf.append(rs)

        tmpval = _mem.dtmf_settings.auto_reset_time
        if tmpval > 60 or tmpval < 5:
            tmpval = 5
        rs = RadioSetting("dtmf_auto_reset_time",
                          "自动复位时间 (秒)",
                          RadioSettingValueInteger(5, 60, tmpval))
        dtmf.append(rs)

        tmpval = int(_mem.dtmf_settings.preload_time)
        if tmpval > 100 or tmpval < 3:
            tmpval = 30
        tmpval *= 10
        rs = RadioSetting("dtmf_preload_time",
                          "预载波时间 (ms)",
                          RadioSettingValueInteger(30, 1000, tmpval, 10))
        dtmf.append(rs)

        tmpval = int(_mem.dtmf_settings.first_code_persist_time)
        if tmpval > 100 or tmpval < 3:
            tmpval = 30
        tmpval *= 10
        rs = RadioSetting("dtmf_first_code_persist_time",
                          "首码持续时间 (ms)",
                          RadioSettingValueInteger(30, 1000, tmpval, 10))
        dtmf.append(rs)

        tmpval = int(_mem.dtmf_settings.hash_persist_time)
        if tmpval > 100 or tmpval < 3:
            tmpval = 30
        tmpval *= 10
        rs = RadioSetting("dtmf_hash_persist_time",
                          "*/# 码持续时间 (ms)",
                          RadioSettingValueInteger(30, 1000, tmpval, 10))
        dtmf.append(rs)

        tmpval = int(_mem.dtmf_settings.code_persist_time)
        if tmpval > 100 or tmpval < 3:
            tmpval = 30
        tmpval *= 10
        rs = RadioSetting("dtmf_code_persist_time",
                          "单码持续时间 (ms)",
                          RadioSettingValueInteger(30, 1000, tmpval, 10))
        dtmf.append(rs)

        tmpval = int(_mem.dtmf_settings.code_interval_time)
        if tmpval > 100 or tmpval < 3:
            tmpval = 30
        tmpval *= 10
        rs = RadioSetting("dtmf_code_interval_time",
                          "码间间隔时间 (ms)",
                          RadioSettingValueInteger(30, 1000, tmpval, 10))
        dtmf.append(rs)

        tmpval = bool(_mem.dtmf_settings.permit_remote_kill > 0)
        rs = RadioSetting(
                "dtmf_permit_remote_kill",
                "允许遥毙",
                RadioSettingValueBoolean(tmpval))
        dtmf.append(rs)

        tmpval = str(_mem.dtmf_settings_numbers.dtmf_local_code).upper().strip(
                "\x00\xff\x20")
        for i in tmpval:
            if i in DTMF_CHARS_ID:
                continue
            else:
                tmpval = "103"
                break
        val = RadioSettingValueString(3, 3, tmpval)
        val.set_charset(DTMF_CHARS_ID)
        rs = RadioSetting("dtmf_dtmf_local_code",
                          "身份码 (3字符 0-9 ABCD)", val)
        dtmf.append(rs)

        tmpval = str(_mem.dtmf_settings_numbers.dtmf_up_code).upper().strip(
                "\x00\xff\x20")
        for i in tmpval:
            if i in DTMF_CHARS_UPDOWN or i == "":
                continue
            else:
                tmpval = "123"
                break
        val = RadioSettingValueString(1, 16, tmpval)
        val.set_charset(DTMF_CHARS_UPDOWN)
        rs = RadioSetting("dtmf_dtmf_up_code",
                          "上线码 (1-16字符 0-9 ABCD*#)", val)
        dtmf.append(rs)

        tmpval = str(_mem.dtmf_settings_numbers.dtmf_down_code).upper().strip(
                "\x00\xff\x20")
        for i in tmpval:
            if i in DTMF_CHARS_UPDOWN:
                continue
            else:
                tmpval = "456"
                break
        val = RadioSettingValueString(1, 16, tmpval)
        val.set_charset(DTMF_CHARS_UPDOWN)
        rs = RadioSetting("dtmf_dtmf_down_code",
                          "下线码 (1-16字符 0-9 ABCD*#)", val)
        dtmf.append(rs)

        tmpval = str(_mem.dtmf_settings_numbers.kill_code).upper().strip(
                "\x00\xff\x20")
        for i in tmpval:
            if i in DTMF_CHARS_KILL:
                continue
            else:
                tmpval = "77777"
                break
        if not len(tmpval) == 5:
            tmpval = "77777"
        val = RadioSettingValueString(5, 5, tmpval)
        val.set_charset(DTMF_CHARS_KILL)
        rs = RadioSetting("dtmf_kill_code",
                          "遥毙码 (5字符 0-9 ABCD)", val)
        dtmf.append(rs)

        tmpval = str(_mem.dtmf_settings_numbers.revive_code).upper().strip(
                "\x00\xff\x20")
        for i in tmpval:
            if i in DTMF_CHARS_KILL:
                continue
            else:
                tmpval = "88888"
                break
        if not len(tmpval) == 5:
            tmpval = "88888"
        val = RadioSettingValueString(5, 5, tmpval)
        val.set_charset(DTMF_CHARS_KILL)
        rs = RadioSetting("dtmf_revive_code",
                          "唤醒码 (5字符 0-9 ABCD)", val)
        dtmf.append(rs)

        val = RadioSettingValueString(0, 80,
                                      "DTMF 联系人为3个字符"
                                      "(有效值: 0-9 * # ABCD), "
                                      "或者是空字符串", charset=VALID_CHARACTERS)
        val.set_mutable(False)
        rs = RadioSetting("dtmf_descr1", "DTMF 联系人", val)
        dtmfc.append(rs)

        for i in range(1, 17):
            varname = "DTMF_" + str(i)
            varnumname = "DTMFNUM_" + str(i)
            vardescr = "联系人" + str(i) + " | 名称"
            varinumdescr = "联系人" + str(i) + " | 号码"

            cntn = str(_mem.dtmfcontact[i-1].name).strip("\x20\x00\xff")
            cntnum = str(_mem.dtmfcontact[i-1].number).strip("\x20\x00\xff")

            val = RadioSettingValueString(0, 8, cntn)
            rs = RadioSetting(varname, vardescr, val)
            dtmfc.append(rs)

            val = RadioSettingValueString(0, 3, cntnum)
            val.set_charset(DTMF_CHARS)
            rs = RadioSetting(varnumname, varinumdescr, val)
            dtmfc.append(rs)

        # MDC 联系人
        val = RadioSettingValueString(0, 80,
                                      "MDC ID 应为 4位16进制数字 例如12AB, 联系人名称不能用中文, 请按顺序添加", charset=VALID_CHARACTERS)
        val.set_mutable(False)
        rs = RadioSetting("mdc_descr1", "MDC 联系人", val)
        mdcc.append(rs)

        for i in range(1, 23):
            mdc_id = "MDC_ID_" + str(i)
            mdc_name = "MDC_NAME_" + str(i)
            mdc_id_descr = "联系人" + str(i) + " | MDC ID"
            mdc_name_descr = "联系人" + str(i) + " | 名称"
            if i <= int(_mem.mdc_num):
                mdc_obj = get_mdc_contact_object(_mem, i)
                c_id = ''.join(['{:02X}'.format(int(byte)) for byte in mdc_obj.id])
                c_name = str(mdc_obj.name)

                val = RadioSettingValueString(0, 4, c_id, charset=' 0123456789ABCDEF')
                rs = RadioSetting(mdc_id, mdc_id_descr, val)
                mdcc.append(rs)

                try:
                    val = RadioSettingValueString(0, 14, c_name)
                except Exception:
                    val = RadioSettingValueString(0, 14, '')
                rs = RadioSetting(mdc_name, mdc_name_descr, val)
                mdcc.append(rs)
            else:
                val = RadioSettingValueString(0, 4, '', charset=' 0123456789ABCDEF')
                rs = RadioSetting(mdc_id, mdc_id_descr, val)
                mdcc.append(rs)

                val = RadioSettingValueString(0, 14, '')
                rs = RadioSetting(mdc_name, mdc_name_descr, val)
                mdcc.append(rs)

        # scanlists
        if _mem.scanlist_default == 1:
            tmpsc = 2
        else:
            tmpsc = 1
        rs = RadioSetting("scanlist_default",
                          "默认扫描列表",
                          RadioSettingValueInteger(1, 2, tmpsc))
        scanl.append(rs)

        tmppr = bool((_mem.scanlist1_priority_scan & 1) > 0)
        rs = RadioSetting(
                "scanlist1_priority_scan",
                "扫描列表1 优先信道扫描",
                RadioSettingValueBoolean(tmppr))
        scanl.append(rs)

        tmpch = _mem.scanlist1_priority_ch1 + 1
        if tmpch > 200:
            tmpch = 0
        rs = RadioSetting("scanlist1_priority_ch1",
                          "扫描列表1 优先信道1 (0 - 关闭)",
                          RadioSettingValueInteger(0, 200, tmpch))
        scanl.append(rs)

        tmpch = _mem.scanlist1_priority_ch2 + 1
        if tmpch > 200:
            tmpch = 0
        rs = RadioSetting("scanlist1_priority_ch2",
                          "扫描列表1 优先信道2 (0 - 关闭)",
                          RadioSettingValueInteger(0, 200, tmpch))
        scanl.append(rs)

        tmppr = bool((_mem.scanlist2_priority_scan & 1) > 0)
        rs = RadioSetting(
                "scanlist2_priority_scan",
                "扫描列表2 优先信道扫描",
                RadioSettingValueBoolean(tmppr))
        scanl.append(rs)

        tmpch = _mem.scanlist2_priority_ch1 + 1
        if tmpch > 200:
            tmpch = 0
        rs = RadioSetting("scanlist2_priority_ch1",
                          "扫描列表2 优先信道1 (0 - 关闭)",
                          RadioSettingValueInteger(0, 200, tmpch))
        scanl.append(rs)

        tmpch = _mem.scanlist2_priority_ch2 + 1
        if tmpch > 200:
            tmpch = 0
        rs = RadioSetting("scanlist2_priority_ch2",
                          "扫描列表2 优先信道2 (0 - 关闭)",
                          RadioSettingValueInteger(0, 200, tmpch))
        scanl.append(rs)

        # basic settings

        # call channel
        tmpc = _mem.call_channel+1
        if tmpc > 200:
            tmpc = 1
        rs = RadioSetting("call_channel", "一键即呼信道",
                          RadioSettingValueInteger(1, 200, tmpc))
        basic.append(rs)

        # squelch
        tmpsq = _mem.squelch
        if tmpsq > 9:
            tmpsq = 1
        rs = RadioSetting("squelch", "静噪等级",
                          RadioSettingValueInteger(0, 9, tmpsq))
        basic.append(rs)

        # TOT
        tmptot = _mem.max_talk_time
        if tmptot > 10:
            tmptot = 10
        rs = RadioSetting(
                "tot",
                "发送超时 [分钟]",
                RadioSettingValueInteger(0, 10, tmptot))
        basic.append(rs)

        # NOAA autoscan
        rs = RadioSetting(
                "noaa_autoscan",
                "NOAA自动扫描", RadioSettingValueBoolean(
                    bool(_mem.noaa_autoscan > 0)))
        basic.append(rs)

        # VOX switch
        rs = RadioSetting(
                "vox_switch",
                "声控发射", RadioSettingValueBoolean(
                    bool(_mem.vox_switch > 0)))
        basic.append(rs)

        # VOX Level
        tmpvox = _mem.vox_level+1
        if tmpvox > 10:
            tmpvox = 10
        rs = RadioSetting("vox_level", "声控发射灵敏度",
                          RadioSettingValueInteger(1, 10, tmpvox))
        basic.append(rs)

        # Mic gain
        tmpmicgain = _mem.mic_gain
        if tmpmicgain > 4:
            tmpmicgain = 2
        rs = RadioSetting("mic_gain", "麦克风增益",
                          RadioSettingValueList(MIC_GAIN_LIST, None, tmpmicgain))
        basic.append(rs)

        # Channel display mode
        tmpchdispmode = _mem.channel_display_mode
        if tmpchdispmode >= len(CHANNELDISP_LIST):
            tmpchdispmode = 0
        rs = RadioSetting(
                "channel_display_mode",
                "信道显示模式",
                RadioSettingValueList(
                    CHANNELDISP_LIST,
                    CHANNELDISP_LIST[tmpchdispmode]))
        basic.append(rs)

        # Crossband receiving/transmitting
        tmpcross = _mem.crossband
        if tmpcross >= len(CROSSBAND_LIST):
            tmpcross = 0
        rs = RadioSetting(
                "crossband",
                "跨段收发",
                RadioSettingValueList(
                    CROSSBAND_LIST,
                    CROSSBAND_LIST[tmpcross]))
        basic.append(rs)

        # Battery save
        tmpbatsave = _mem.battery_save
        if tmpbatsave >= len(BATSAVE_LIST):
            tmpbatsave = BATSAVE_LIST.index("1:4")
        rs = RadioSetting(
                "battery_save",
                "省电模式",
                RadioSettingValueList(
                    BATSAVE_LIST,
                    BATSAVE_LIST[tmpbatsave]))
        basic.append(rs)

        # Dual watch
        tmpdual = _mem.dual_watch
        if tmpdual >= len(DUALWATCH_LIST):
            tmpdual = 0
        rs = RadioSetting("dualwatch", "双频守候", RadioSettingValueList(
            DUALWATCH_LIST, DUALWATCH_LIST[tmpdual]))
        basic.append(rs)

        # Backlight auto mode
        tmpback = _mem.backlight_auto_mode
        if tmpback >= len(BACKLIGHT_LIST):
            tmpback = 0
        rs = RadioSetting("backlight_auto_mode",
                          "自动背光",
                          RadioSettingValueList(
                              BACKLIGHT_LIST,
                              BACKLIGHT_LIST[tmpback]))
        basic.append(rs)

        # Tail tone elimination
        rs = RadioSetting(
                "tail_note_elimination",
                "尾音消除",
                RadioSettingValueBoolean(
                    bool(_mem.tail_note_elimination > 0)))
        basic.append(rs)

        # VFO open
        rs = RadioSetting("vfo_open", "频率模式",
                          RadioSettingValueBoolean(bool(_mem.vfo_open > 0)))
        basic.append(rs)

        # Beep control
        rs = RadioSetting(
                "beep_control",
                "按键音",
                RadioSettingValueBoolean(bool(_mem.beep_control > 0)))
        basic.append(rs)

        # Scan resume mode
        tmpscanres = _mem.scan_resume_mode
        if tmpscanres >= len(SCANRESUME_LIST):
            tmpscanres = 0
        rs = RadioSetting(
                "scan_resume_mode",
                "扫描恢复模式",
                RadioSettingValueList(
                    SCANRESUME_LIST,
                    SCANRESUME_LIST[tmpscanres]))
        basic.append(rs)

        # Keypad locked
        rs = RadioSetting(
                "key_lock",
                "按键锁定",
                RadioSettingValueBoolean(bool(_mem.key_lock > 0)))
        basic.append(rs)

        # Auto keypad lock
        rs = RadioSetting(
                "auto_keypad_lock",
                "按键自动锁定",
                RadioSettingValueBoolean(bool(_mem.auto_keypad_lock > 0)))
        basic.append(rs)

        # Power on display mode
        tmpdispmode = _mem.power_on_dispmode
        if tmpdispmode >= len(WELCOME_LIST):
            tmpdispmode = 0
        rs = RadioSetting(
                "welcome_mode",
                "开机显示",
                RadioSettingValueList(
                    WELCOME_LIST,
                    WELCOME_LIST[tmpdispmode]))
        basic.append(rs)

        # Keypad Tone
        tmpkeypadtone = _mem.keypad_tone
        if tmpkeypadtone >= len(KEYPADTONE_LIST):
            tmpkeypadtone = 0
        rs = RadioSetting("keypad_tone", "按键语音", RadioSettingValueList(
            KEYPADTONE_LIST, KEYPADTONE_LIST[tmpkeypadtone]))
        basic.append(rs)

        # Language
        tmplanguage = _mem.language
        if tmplanguage >= len(LANGUAGE_LIST):
            tmplanguage = 0
        rs = RadioSetting("language", "语言", RadioSettingValueList(
            LANGUAGE_LIST, LANGUAGE_LIST[tmplanguage]))
        basic.append(rs)

        # Alarm mode
        tmpalarmmode = _mem.alarm_mode
        if tmpalarmmode >= len(ALARMMODE_LIST):
            tmpalarmmode = 0
        rs = RadioSetting("alarm_mode", "紧急告警模式", RadioSettingValueList(
            ALARMMODE_LIST, ALARMMODE_LIST[tmpalarmmode]))
        basic.append(rs)

        # Reminding of end of talk
        tmpalarmmode = _mem.reminding_of_end_talk
        if tmpalarmmode >= len(REMENDOFTALK_LIST):
            tmpalarmmode = 0
        rs = RadioSetting(
                "reminding_of_end_talk",
                "首尾音",
                RadioSettingValueList(
                    REMENDOFTALK_LIST,
                    REMENDOFTALK_LIST[tmpalarmmode]))
        basic.append(rs)

        # Repeater tail tone elimination
        tmprte = _mem.repeater_tail_elimination
        if tmprte >= len(RTE_LIST):
            tmprte = 0
        rs = RadioSetting(
                "repeater_tail_elimination",
                "过中继尾音消除",
                RadioSettingValueList(RTE_LIST, RTE_LIST[tmprte]))
        basic.append(rs)

        # Logo string 1
        if self.FIRMWARE_VERSION.endswith('K'):
            logo1 = convert_bytes_to_chinese(self._welcome_logo[0])
            rs = RadioSetting("logo1", "欢迎字符1 (18字符)",
                              RadioSettingChineseValueString(0, 18, logo1, False, VALID_CHARACTERS))
        else:
            logo1 = str(_mem.logo_line1).strip("\x20\x00\xff") + "\x00"
            logo1 = _getstring(logo1.encode('ascii', errors='ignore'), 0, 12)
            rs = RadioSetting("logo1", "欢迎字符1 (12字符)",
                              RadioSettingChineseValueString(0, 12, logo1, False))
        basic.append(rs)

        # Logo string 2
        if self.FIRMWARE_VERSION.endswith('K'):
            logo2 = convert_bytes_to_chinese(self._welcome_logo[1])
            rs = RadioSetting("logo2", "欢迎字符2 (18字符)",
                              RadioSettingChineseValueString(0, 18, logo2, False, VALID_CHARACTERS))
        else:
            logo2 = str(_mem.logo_line2).strip("\x20\x00\xff") + "\x00"
            logo2 = _getstring(logo2.encode('ascii', errors='ignore'), 0, 12)
            rs = RadioSetting("logo2", "欢迎字符2 (12字符)",
                              RadioSettingChineseValueString(0, 12, logo2, False))
        basic.append(rs)

        # FM radio
        for i in range(1, 21):
            freqname = "FM_"+str(i)
            fmfreq = _mem.fmfreq[i-1]/10.0
            if fmfreq < FMMIN or fmfreq > FMMAX:
                rs = RadioSetting(freqname, freqname,
                                  RadioSettingValueString(0, 5, ""))
            else:
                rs = RadioSetting(freqname, freqname,
                                  RadioSettingValueString(0, 5, str(fmfreq)))

            fmradio.append(rs)

        # unlock settings

        # F-LOCK
        tmpflock = _mem.lock_flock
        if tmpflock >= len(FLOCK_LIST):
            tmpflock = 0
        rs = RadioSetting(
            "flock", "频段解锁",
            RadioSettingValueList(FLOCK_LIST, FLOCK_LIST[tmpflock]))
        unlock.append(rs)

        # # 350TX
        # rs = RadioSetting("tx350", "350TX - unlock 350-400 MHz TX",
        #                   RadioSettingValueBoolean(
        #                       bool(_mem.lock.tx350 > 0)))
        # unlock.append(rs)

        # Killed
        rs = RadioSetting("Killed", "遥毙禁用",
                          RadioSettingValueBoolean(
                              bool(_mem.lock_killed > 0)))
        unlock.append(rs)

        # # 200TX
        # rs = RadioSetting("tx200", "200TX - unlock 174-350 MHz TX",
        #                   RadioSettingValueBoolean(
        #                       bool(_mem.lock.tx200 > 0)))
        # unlock.append(rs)
        #
        # # 500TX
        # rs = RadioSetting("tx500", "500TX - unlock 500-600 MHz TX",
        #                   RadioSettingValueBoolean(
        #                       bool(_mem.lock.tx500 > 0)))
        # unlock.append(rs)
        #
        # # 350EN
        # rs = RadioSetting("en350", "350EN - unlock 350-400 MHz RX",
        #                   RadioSettingValueBoolean(
        #                       bool(_mem.lock.en350 > 0)))
        # unlock.append(rs)

        # SCREEN
        rs = RadioSetting("scrambler", "扰频",
                          RadioSettingValueBoolean(
                              bool(_mem.lock_enscramble > 0)))
        unlock.append(rs)

        # readonly info
        # Firmware
        if self.FIRMWARE_VERSION == "":
            firmware = "获取固件版本需要先从电台下载数据"
        else:
            firmware = self.FIRMWARE_VERSION

        val = RadioSettingValueString(0, 128, firmware, charset=VALID_CHARACTERS)
        val.set_mutable(False)
        rs = RadioSetting("fw_ver", "固件版本", val)
        roinfo.append(rs)

        # No limits version for hacked firmware
        val = RadioSettingValueBoolean(self._expanded_limits)
        rs = RadioSetting("nolimits", "禁用限制(适用于第三方固件)",
                          val)
        rs.set_warning(
            '只有在使用宽频的第三方固件时，才应启用此功能。启用此选项将 CHIRP 无视 OEM 限制，可能导致未定义或未规范的行为。风险自负！',
            safe_value=False
        )
        roinfo.append(rs)

        return top

    # Store details about a high-level memory to the memory map
    # This is called when a user edits a memory in the UI
    def set_memory(self, mem):
        number = mem.number-1

        # Get a low-level memory object mapped to the image
        _mem = self._memobj.channel[number]
        _mem4 = self._memobj
        # empty memory
        if mem.empty:
            _mem.set_raw("\xFF" * 16)
            if number < 200:
                _mem2 = self._memobj.channelname[number]
                _mem2.set_raw("\xFF" * 16)
                _mem4.channel_attributes[number].is_scanlist1 = 0
                _mem4.channel_attributes[number].is_scanlist2 = 0
                _mem4.channel_attributes[number].unknown1 = 0
                _mem4.channel_attributes[number].unknown2 = 0
                _mem4.channel_attributes[number].is_free = 1
                _mem4.channel_attributes[number].band = 0x7
            return mem

        # clean the channel memory, restore some bits if it was used before
        if _mem.get_raw(asbytes=False)[0] == "\xff":
            # this was an empty memory
            _mem.set_raw("\x00" * 16)
        else:
            # this memory wasn't empty, save some bits that we don't know the
            # meaning of, or that we don't support yet
            prev_0a = _mem.get_raw()[0x0a] & SAVE_MASK_0A
            prev_0b = _mem.get_raw()[0x0b] & SAVE_MASK_0B
            prev_0c = _mem.get_raw()[0x0c] & SAVE_MASK_0C
            prev_0d = _mem.get_raw()[0x0d] & SAVE_MASK_0D
            prev_0e = _mem.get_raw()[0x0e] & SAVE_MASK_0E
            prev_0f = _mem.get_raw()[0x0f] & SAVE_MASK_0F
            _mem.set_raw("\x00" * 10 +
                         chr(prev_0a) + chr(prev_0b) + chr(prev_0c) +
                         chr(prev_0d) + chr(prev_0e) + chr(prev_0f))

        if number < 200:
            _mem4.channel_attributes[number].is_scanlist1 = 0
            _mem4.channel_attributes[number].is_scanlist2 = 0
            _mem4.channel_attributes[number].unknown1 = 0
            _mem4.channel_attributes[number].unknown2 = 0
            _mem4.channel_attributes[number].is_free = 1
            _mem4.channel_attributes[number].band = 0x7

        # find band
        band = _find_band(self, mem.freq)

        # mode
        if mem.mode == "NFM":
            _mem.bandwidth = 1
            _mem.enable_am = 0
        elif mem.mode == "FM":
            _mem.bandwidth = 0
            _mem.enable_am = 0
        elif mem.mode == "NAM":
            _mem.bandwidth = 1
            _mem.enable_am = 1
        elif mem.mode == "AM":
            _mem.bandwidth = 0
            _mem.enable_am = 1

        # frequency/offset
        _mem.freq = mem.freq/10
        _mem.offset = mem.offset/10

        if mem.duplex == "":
            _mem.offset = 0
            _mem.shift = 0
        elif mem.duplex == '-':
            _mem.shift = FLAGS1_OFFSET_MINUS
        elif mem.duplex == '+':
            _mem.shift = FLAGS1_OFFSET_PLUS
        elif mem.duplex == 'off':
            # we fake tx disable by setting the tx freq to 0 MHz
            _mem.shift = FLAGS1_OFFSET_MINUS
            _mem.offset = _mem.freq

        # set band
        if number < 200:
            _mem4.channel_attributes[number].is_free = 0
            _mem4.channel_attributes[number].band = band

        # channels >200 are the 14 VFO chanells and don't have names
        if number < 200:
            _mem2 = self._memobj.channelname[number]
            text = convert_chinese_to_ascii_chars(mem.name)
            if len(text) < 16:
                text += "\x00" * (16-len(text))
            elif len(text) >= 16:
                text = text[:16]
            _mem2.name = text  # Store the alpha tag

        # tone data
        self._set_tone(mem, _mem)

        # step
        _mem.step = STEPS.index(mem.tuning_step)

        # tx power
        if str(mem.power) == str(UVK5_POWER_LEVELS[2]):
            _mem.txpower = POWER_HIGH
        elif str(mem.power) == str(UVK5_POWER_LEVELS[1]):
            _mem.txpower = POWER_MEDIUM
        else:
            _mem.txpower = POWER_LOW

        for setting in mem.extra:
            sname = setting.get_name()
            svalue = setting.value.get_value()

            if sname == "bclo":
                _mem.bclo = svalue and 1 or 0

            if sname == "pttid":
                _mem.dtmf_pttid = PTTID_LIST.index(svalue)

            if sname == "frev":
                _mem.freq_reverse = svalue and 1 or 0

            if sname == "dtmfdecode":
                _mem.dtmf_decode = svalue and 1 or 0

            if sname == "scrambler":
                _mem.scrambler = (
                    _mem.scrambler & 0xf0) | SCRAMBLER_LIST.index(svalue)

            if number < 200 and sname == "scanlists":
                if svalue == "1":
                    _mem4.channel_attributes[number].is_scanlist1 = 1
                    _mem4.channel_attributes[number].is_scanlist2 = 0
                elif svalue == "2":
                    _mem4.channel_attributes[number].is_scanlist1 = 0
                    _mem4.channel_attributes[number].is_scanlist2 = 1
                elif svalue == "1+2":
                    _mem4.channel_attributes[number].is_scanlist1 = 1
                    _mem4.channel_attributes[number].is_scanlist2 = 1
                else:
                    _mem4.channel_attributes[number].is_scanlist1 = 0
                    _mem4.channel_attributes[number].is_scanlist2 = 0

        return mem